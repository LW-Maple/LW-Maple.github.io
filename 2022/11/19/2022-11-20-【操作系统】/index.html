<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统 | 漫漫长夜</title><meta name="keywords" content="操作系统"><meta name="author" content="Lost丶逝水如风"><meta name="copyright" content="Lost丶逝水如风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统的基本概念操作系统是指一种管理计算机系统硬件和软件资源的程序，它负责控制和管理计算机的硬件资源和软件资源，为其他应用程序提供基本的服务和支持。  换句话说，操作系统是计算机系统的管理者和调度者。  操作系统的资源管理功能 资源管理：操作系统负责管理计算机系统的硬件和软件资源，如内存、CPU、I&#x2F;O设备、文件系统等  进程管理：操作系统能够创建、调度、管理和终止进程，控制进程之间的">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://lw-maple.github.io/2022/11/19/2022-11-20-%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91/index.html">
<meta property="og:site_name" content="漫漫长夜">
<meta property="og:description" content="操作系统的基本概念操作系统是指一种管理计算机系统硬件和软件资源的程序，它负责控制和管理计算机的硬件资源和软件资源，为其他应用程序提供基本的服务和支持。  换句话说，操作系统是计算机系统的管理者和调度者。  操作系统的资源管理功能 资源管理：操作系统负责管理计算机系统的硬件和软件资源，如内存、CPU、I&#x2F;O设备、文件系统等  进程管理：操作系统能够创建、调度、管理和终止进程，控制进程之间的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lw-maple.github.io/img/coverImg/0.jpg">
<meta property="article:published_time" content="2022-11-19T07:41:28.000Z">
<meta property="article:modified_time" content="2023-06-07T02:05:13.147Z">
<meta property="article:author" content="Lost丶逝水如风">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lw-maple.github.io/img/coverImg/0.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lw-maple.github.io/2022/11/19/2022-11-20-%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/img/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-07 10:05:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/self/atom-one-dark.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GJ411x7h7"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/coverImg/0.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">漫漫长夜</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GJ411x7h7"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-19T07:41:28.000Z" title="发表于 2022-11-19 15:41:28">2022-11-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-07T02:05:13.147Z" title="更新于 2023-06-07 10:05:13">2023-06-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS/">CS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h1><p>操作系统是指一种<strong>管理计算机系统硬件和软件资源的程序</strong>，<strong>它负责控制和管理计算机的硬件资源和软件资源，为其他应用程序提供基本的服务和支持。</strong></p>
<blockquote>
<p>换句话说，操作系统是计算机系统的管理者和调度者。</p>
</blockquote>
<h2 id="操作系统的资源管理功能"><a href="#操作系统的资源管理功能" class="headerlink" title="操作系统的资源管理功能"></a>操作系统的资源管理功能</h2><ul>
<li><p>资源管理：操作系统负责管理计算机系统的硬件和软件资源，如内存、CPU、I&#x2F;O设备、文件系统等</p>
</li>
<li><p>进程管理：操作系统能够创建、调度、管理和终止进程，控制进程之间的并发和同步，确保系统中的进程能够正确地共享资源并协同工作。</p>
</li>
<li><p>内存管理：操作系统负责管理内存资源，为进程提供虚拟地址空间和内存保护机制，从而保证系统的安全性和稳定性。</p>
</li>
<li><p>文件管理：操作系统能够管理计算机系统中的文件和目录结构，提供对文件的访问和保护，以及文件共享和备份等功能。</p>
</li>
<li><p>设备管理：操作系统负责管理和调度计算机系统中的各种输入输出设备，如磁盘、打印机、键盘、鼠标等</p>
</li>
</ul>
<h2 id="操作系统的特性"><a href="#操作系统的特性" class="headerlink" title="操作系统的特性"></a>操作系统的特性</h2><ul>
<li><p>并发性（Concurrency）：操作系统需要同时处理多个进程或线程的请求，因此，操作系统必须具有并发管理的能力，确保这些进程或线程能够按照一定的优先级和调度算法得到合理的分配和调度。</p>
</li>
<li><p>共享性（Sharing）：操作系统能够管理计算机系统的各种资源，包括 CPU、内存、磁盘、打印机等，这些资源需要被多个进程或线程同时共享。操作系统需要提供相应的机制，确保这些资源能够被多个进程或线程合理地共享，同时保证系统的稳定性和安全性。</p>
</li>
<li><p>虚拟性（Virtualization）：操作系统需要为每个进程或线程提供一个独立的虚拟地址空间，使得每个进程或线程感觉到自己在独占计算机系统的全部资源。<strong>这种虚拟性机制使得操作系统能够更好地管理计算机系统的资源</strong></p>
<ul>
<li>虚拟地址空间也可以为进程间通信提供支持</li>
<li>由于每个进程或线程只能访问自己的虚拟地址空间，所以它们无法访问其他进程或线程的内存数据</li>
</ul>
</li>
<li><p>异步性（Asynchrony）：操作系统需要处理来自各种外部设备的异步事件，如鼠标点击、键盘输入、网络通信等。确保系统的快速响应和高效处理。</p>
</li>
<li><p>持久性（Persistence）：操作系统需要提供文件系统和数据存储管理等功能，使得计算机系统能够长期存储和保护用户数据，即使计算机系统断电或崩溃也能够恢复数据。</p>
</li>
<li><p>可扩展性（Scalability）：操作系统也需要支持动态加载和卸载模块的能力，以适应计算机系统的不断变化和演进。</p>
</li>
</ul>
<blockquote>
<p>关于虚拟性：一个经典的例子：当我们打开一个 Web 浏览器时，操作系统会为浏览器分配一定的虚拟地址空间，用于存储浏览器程序的代码、数据和运行时状态。这个虚拟地址空间与其他进程或线程的虚拟地址空间相互隔离，确保浏览器程序不会影响其他应用程序的正常运行。同时，如果我们同时打开多个浏览器窗口，每个窗口都会被分配一个独立的虚拟地址空间，从而避免了它们之间的内存干扰和冲突。</p>
</blockquote>
<h1 id="存储式计算机"><a href="#存储式计算机" class="headerlink" title="存储式计算机"></a>存储式计算机</h1><h2 id="存储式计算机的结构和特点"><a href="#存储式计算机的结构和特点" class="headerlink" title="存储式计算机的结构和特点"></a>存储式计算机的结构和特点</h2><p>存储程序式计算机是一种计算机体系结构<strong>，其主要特点是程序和数据都存储在内存中，CPU按照程序的指令序列依次取出指令并执行。</strong></p>
<h2 id="计算机系统结构和操作系统之间的关系"><a href="#计算机系统结构和操作系统之间的关系" class="headerlink" title="计算机系统结构和操作系统之间的关系"></a>计算机系统结构和操作系统之间的关系</h2><ul>
<li><p><strong>计算机系统结构指的是计算机硬件的组织结构</strong>和功能特点，包括CPU、内存、输入输出设备等。<strong>操作系统则是计算机系统中的一种软件</strong>，负责管理计算机硬件资源、控制程序执行、提供服务接口等。</p>
</li>
<li><p><strong>操作系统直接运行在计算机系统结构之上</strong>，通过操作硬件资源来实现各种应用程序的执行。操作系统管理计算机的各种资源，如内存、进程、文件系统、网络等等，为上层应用程序提供了一种统一的抽象接口，使得应用程序可以更方便地调用系统资源。</p>
</li>
</ul>
<h1 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h1><ol>
<li>手动控制阶段（1940年代前期）：在这个阶段，<strong>计算机是由人手动控制运行的</strong>。程序员需要手动设置计算机开关和电路来完成特定的任务。</li>
<li>批处理阶段（1950年代早期）：批处理操作系统出现了，<strong>程序员将一系列任务提交给操作系统，操作系统自动执行这些任务</strong>，完成后返回结果。这种方式提高了计算机的效率，但是缺乏交互性。</li>
<li>分时系统阶段（1960年代）：随着计算机性能的提升，分时系统出现了。<strong>多个用户可以同时通过终端访问计算机，并共享计算机资源</strong>。在这个阶段，操作系统需要处理用户的输入输出请求，并进行调度管理。</li>
<li>多道程序设计阶段（1960年代晚期）：在这个阶段，操作系统可以同时管理多个程序的运行，<strong>操作系统可以在多个程序之间进行切换，以实现更高效的资源利用。</strong></li>
<li>个人计算机时代（1980年代）：随着个人计算机的出现，操作系统也得到了快速发展。DOS、Windows、Mac OS等操作系统相继出现，为个人计算机提供了更好的用户界面和易用性。</li>
<li>网络时代（1990年代）：随着互联网的出现，操作系统需要处理更多的网络连接请求和安全问题，Linux和Windows NT等操作系统应运而生，为网络时代的计算机提供了更好的支持。</li>
<li>云计算时代（2000年代后期）：随着云计算的兴起，操作系统需要支持大规模的分布式系统和虚拟化技术，操作系统也需要更好地支持云计算环境下的自动化管理和弹性伸缩。</li>
</ol>
<h2 id="批量操作系统"><a href="#批量操作系统" class="headerlink" title="批量操作系统"></a>批量操作系统</h2><ul>
<li>在批量操作系统中，用户可以将自己编写的程序提交到计算机系统，系统会将这些作业按照一定的顺序排列，并自动进行调度和执行。当一个作业执行完毕后，操作系统会自动将下一个作业装入内存并执行，直到所有作业都完成为止。</li>
</ul>
<blockquote>
<p>批量操作系统的出现，是计算机历史上的一个重要里程碑。在早期计算机系统中，每个程序都需要手动地输入并执行，这样的工作方式效率极低，资源利用率也非常低。随着批量操作系统的出现，计算机系统的效率得到了极大的提高，用户也可以更加方便地使用计算机资源。</p>
</blockquote>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><ul>
<li>在分时操作系统中，多个用户可以通过终端或者远程登录的方式，同时访问计算机系统。操作系统会将每个用户的请求按照一定的顺序分时分配处理，每个用户都可以独立地使用计算机系统的资源，并且不会相互干扰。</li>
</ul>
<blockquote>
<p>分时操作系统的出现，极大地提高了计算机系统的资源利用率。在分时操作系统下，多个用户可以共享计算机系统的资源，这样可以大大减少计算机系统的闲置时间，提高资源的利用率。同时，分时操作系统也为用户提供了更加便捷的使用方式，可以让多个用户同时使用同一台计算机系统，从而满足更多用户的需求。</p>
</blockquote>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>实时操作系统（Real-Time Operating System，RTOS）是一种专门为实时应用程序设计的操作系统。<strong>它的主要特点是能够保证系统对外界事件及时响应并做出相应的处理</strong>，使得应用程序在规定的时间内完成响应，并能够满足实时性、可靠性和稳定性的要求。</p>
<blockquote>
<p>实时操作系统通常被用于需要及时响应的应用场景，如军事、航天、汽车电子、医疗器械等领域。在这些场景下，任务完成的时限非常紧迫，系统需要在预定的时间内完成任务，并对外界的事件做出实时响应。实时操作系统可以通过对任务进行优先级调度和时间片轮转等策略，来保证任务的及时执行和响应。</p>
</blockquote>
<h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><p>网络操作系统（Network Operating System，NOS）<strong>是一种专门用于管理计算机网络的操作系统。</strong>与传统的个人计算机操作系统不同，网络操作系统主要关注计算机网络上的资源管理、安全控制、网络通信等方面的功能。</p>
<h2 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h2><p>分布式操作系统（Distributed Operating System，DOS）是一种运行在多台计算机上的操作系统，<strong>它将多台计算机组成一个统一的计算机系统，使得不同计算机之间可以协同工作，共享资源，并提供统一的用户接口</strong>。</p>
<h1 id="操作系统的组织结构"><a href="#操作系统的组织结构" class="headerlink" title="操作系统的组织结构"></a>操作系统的组织结构</h1><p>操作系统的组织结构通常分为两个层次：内核（Kernel）和用户接口（User Interface）。</p>
<ul>
<li><p>内核（Kernel）层次：<strong>内核是操作系统的核心部分，负责管理计算机硬件资源，提供系统调用接口，为应用程序提供服务。</strong>内核通常被设计为一个层次化的结构，包括多个模块或者子系统，每个模块或子系统负责不同的任务，例如内存管理、进程管理、文件系统、网络协议等。内核的设计需要考虑高效、可靠和安全等因素，因为内核是整个系统的核心，任何故障都可能导致系统崩溃或数据丢失。</p>
</li>
<li><p>用户接口（User Interface）层次：<strong>用户接口是操作系统与用户交互的部分</strong>，包括命令行接口、图形用户界面、API等。用户接口通常被设计为与内核分离的模块，这样可以降低内核的复杂度，提高系统的可维护性和可扩展性。用户接口需要提供易用、友好、安全和高效的交互方式，让用户能够方便地使用操作系统和应用程序。</p>
</li>
</ul>
<h1 id="处理机状态及分类"><a href="#处理机状态及分类" class="headerlink" title="处理机状态及分类"></a>处理机状态及分类</h1><p>内核，是一个操作系统的核心。是基于硬件的第一层软件扩充，提供操作系统的最基本的功能，是操作系统工作的基础，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。</p>
<p>　　内核是操作系统的内部核心程序，它向外部提供了对计算机设备的核心管理调用。我们将操作系统的代码分成2部分。内核所在的地址空间称作内核空间。而在内核以外的统称为外部管理程序，它们大部分是对外围设备的管理和界面操作。外部管理程序与用户进程所占据的地址空间称为外部空间。通常，一个程序会跨越两个空间。当执行到内河空间的一段代码时，我们称程序处于内核态，而当程序执行到外部空间代码时，我们称程序处于用户态。</p>
<p>处理器的状态可以根据其运行的特权级别进行分类</p>
<ul>
<li><p>通常有管态（Kernel Mode）和用户态（User Mode）两种状态。</p>
</li>
<li><p>管态是指处理器执行特权指令时所处的状态，具有完全的访问权限，可以访问所有的系统资源，如内存、I&#x2F;O设备等，同时也可以执行特权指令，如修改系统状态和进行中断处理等。</p>
</li>
<li><p>而用户态则是指处理器执行用户程序时所处的状态，具有较低的访问权限，只能访问自己的内存空间和一些受限制的资源，不能直接访问系统资源，也不能执行特权指令。</p>
</li>
</ul>
<blockquote>
<p>操作系统利用处理器的管态和用户态来实现对<strong>系统资源的保护和管理</strong>。当进程处于用户态时，它只能访问自己的资源，不能修改系统状态，这样可以避免进程之间相互干扰和影响系统的稳定性。</p>
<p>而当进程需要访问系统资源或执行特权指令时，操作系统会将处理器的状态从用户态切换到管态，完成相应的操作后再切换回用户态，从而实现对系统的保护和管理</p>
</blockquote>
<h2 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h2><p>在计算机系统中，特权指令是只有操作系统内核或特权级别较高的程序才能执行的指令。这些指令通常可以访问和控制系统资源，如内存、I&#x2F;O设备、中断控制器等，以及修改系统状态，如进程调度、内存管理等</p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断是计算机系统中的一种机制，用于在处理器执行程序时暂停当前任务并转而执行另一个任务或服务请求，以响应外部事件或异常条件。</p>
<ul>
<li>当一个设备需要处理器的服务时，它会发出一个中断信号，中断控制器会将该信号转发给处理器。处理器在接收到中断信号后会停止当前任务的执行，保存当前的状态（如程序计数器、寄存器状态等），并跳转到中断服务程序中去执行相应的处理。</li>
</ul>
<blockquote>
<p>如果你按下键盘上的某个按键，键盘会发送一个中断信号给处理器，告诉处理器有一个按键被按下了。处理器会暂停当前正在执行的任务，保存当前的状态，跳转到操作系统的键盘中断服务程序中去处理这个中断事件。键盘中断服务程序会读取键盘缓冲区中的数据，将键盘输入转换成字符并发送给应用程序。</p>
</blockquote>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><ul>
<li><p>硬件中断：由硬件设备（如键盘、鼠标、网络接口卡等）发起的中断。硬件中断可以进一步分为外部中断和内部中断。</p>
</li>
<li><p>软件中断：由软件程序（如操作系统、应用程序等）发起的中断。软件中断又可以分为陷阱、系统调用和软中断。</p>
</li>
<li><p>同步中断：由当前程序执行时的程序指令所引起的中断，也称为异常。例如，处理器执行一条非法的指令、访问非法的内存地址、发生除零错误等都会导致同步中断。</p>
</li>
<li><p>异步中断：由计算机系统中的外部事件所引起的中断。例如，硬件故障、IO操作完成、时钟中断等都属于异步中断。</p>
</li>
<li><p>内部中断：由处理器执行指令时产生的中断，也称为处理器异常。例如，缺页中断、栈溢出中断等都属于内部中断。</p>
</li>
</ul>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>在操作系统中，并发（Concurrency）是指系统能够同时执行多个独立的活动或任务的能力。具体来说，并发是指多个程序或进程在同一时间间隔内进行执行，给人一种它们在同时执行的错觉。</p>
<blockquote>
<p>程序的并发执行是指程序中的多个部分（线程、进程或任务）同时执行的能力。与顺序执行相比，并发执行可以在同一时间内处理多个任务，从而提高程序的效率和响应能力。以下是一些使用并发执行的主要原因：</p>
</blockquote>
<ul>
<li>并发程序的特点<ul>
<li>失去程序的封闭性</li>
<li>程序与计算不再一一对应</li>
<li>程序并发执行的相互制约</li>
</ul>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程（Process）是指<strong>正在运行中的程序的实例</strong>。它是操作系统对程序的一种抽象表示，表示一个独立的执行单元，具有独立的内存空间、代码、数据和系统资源。</p>
<ul>
<li><p>每个进程都是在操作系统中分配的一块内存空间，用于<strong>存储程序的指令、数据和运行时的堆栈</strong>等。进程可以<strong>包含一个或多个线程</strong>（Thread），每个线程都是在进程内部执行的独立的执行序列。</p>
</li>
<li><p>进程拥有自己的运行状态，包括就绪、运行和阻塞等状态。它可以通过操作系统的调度机制获得处理器的时间片并执行指令。进程还可以通过系统调用来申请和释放系统资源，如文件、网络连接、设备等。</p>
</li>
<li><p>每个进程都有一个唯一的进程标识符（Process Identifier，PID），用于在操作系统中进行识别和管理。进程之间是相互独立的，它们之间不能直接访问彼此的内存空间，需要通过操作系统提供的机制进行进程间的通信和同步。</p>
</li>
<li><p>进程可以并发地执行，即多个进程可以在同一时间内运行在不同的处理器核心或分布式系统上。操作系统负责对进程进行调度和资源管理，以实现并发执行和资源的合理利用。</p>
</li>
<li><p>进程分为系统进程和用户进程</p>
<ul>
<li>系统进程：系统进程是在操作系统内核（Kernel）运行的进程，具有特殊的权限和特权。这些进程负责操作系统的核心功能，如调度其他进程、管理内存、文件系统和设备等。</li>
<li>用户进程：用户进程是由用户创建的普通进程，以执行特定的任务和应用程序。它们是在用户的权限下运行，并且受到操作系统的限制和保护。</li>
</ul>
</li>
</ul>
<blockquote>
<p>进程是操作系统中的重要概念，它提供了隔离、并发和资源管理等功能，使得多个程序可以同时运行，并能相互独立地进行计算和操作。</p>
</blockquote>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>三种基本状态</p>
<ul>
<li>就绪状态ready：进程已经分配除CPU以外的所有必要资源，只要在获得CPU就可立刻执行。</li>
<li>执行状态running：进程已获得CPU，其程序正在执行的状态。</li>
<li>阻塞状态block：正在执行的进程由于发生某事件（如IO请求、申请缓冲区失败等）暂时无法继续执行的状态。</li>
</ul>
<img src="https://s1.ax1x.com/2023/06/07/pCifmh4.png" alt="进程三态模型" style="zoom:33%;" />

<p>进程的五态模型</p>
<img src="https://img-blog.csdnimg.cn/img_convert/0ccd9fb2a039d821ab2c62428ca97228.png#pic_center" alt="五态" style="zoom:50%;" />

<h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>进程控制块（Process Control Block，PCB），也称为任务控制块（Task Control Block），是操作系统中用于<strong>管理和维护进程信息的数据结构</strong>。每个运行或等待执行的进程都有一个对应的PCB。</p>
<table>
<thead>
<tr>
<th>PCB 属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>进程标识符 (PID)</td>
<td>用于唯一标识进程的数值</td>
</tr>
<tr>
<td>状态</td>
<td>进程的当前状态（例如：就绪、运行、阻塞）</td>
</tr>
<tr>
<td>程序计数器 (PC)</td>
<td>指向当前正在执行的指令的地址</td>
</tr>
<tr>
<td>寄存器信息</td>
<td>保存进程的寄存器状态，包括通用寄存器、栈指针、堆指针等</td>
</tr>
<tr>
<td>内存管理信息</td>
<td>进程的内存分配情况和地址空间等</td>
</tr>
<tr>
<td>资源信息</td>
<td>记录进程所占用的资源和打开的文件等信息</td>
</tr>
<tr>
<td>进程优先级</td>
<td>用于调度算法确定进程的优先级顺序</td>
</tr>
<tr>
<td>父子关系</td>
<td>记录进程的父进程和子进程之间的关系</td>
</tr>
</tbody></table>
<blockquote>
<p>PCB的主要作用是存储和维护进程的上下文信息，以及为操作系统提供管理和调度进程所需的数据。当进程被调度执行、阻塞或唤醒时，操作系统会根据PCB中的信息进行相应的操作。</p>
<p>通过PCB，操作系统可以跟踪和管理多个进程的状态、资源和执行情况，实现进程的调度、切换和协调。PCB的创建、更新和销毁是操作系统中进程管理的关键操作之</p>
</blockquote>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（Thread）是在进程内部执行的独立执行序列。它是进程中的一个实体，用于执行特定的任务或子任务。线程是操作系统调度的最小单位，也是程序并发执行的基本单位。</p>
<p>与进程不同，线程是在进程内部创建和管理的，并共享进程的资源和上下文。一个进程可以包含一个或多个线程，它们共享进程的内存空间、文件描述符、打开的文件等资源。每个线程有自己的栈空间，用于保存函数调用和局部变量等信息。</p>
<h2 id="进程之间的状态"><a href="#进程之间的状态" class="headerlink" title="进程之间的状态"></a>进程之间的状态</h2><ul>
<li>进程竞争（Process Competition）指的是多个进程在竞争有限的系统资源时发生的情况。系统资源可以是CPU的处理时间、内存空间、磁盘IO等。</li>
<li>进程合作（Process Cooperation）指的是多个进程之间相互协作和通信的情况。进程合作通常是为了完成更大的任务或解决更复杂的问题，需要多个进程之间进行协同工作。</li>
</ul>
<p><strong>进程互斥和同步</strong>是用于<strong>协调进程之间的执行</strong>的两个重要概念。</p>
<ul>
<li><p>进程互斥（Process Mutual Exclusion）是指在多个进程之间保持互斥访问共享资源的机制。当一个进程访问某个共享资源时，其他进程必须等待该进程释放资源后才能访问。这样可以避免多个进程同时访问共享资源造成的数据竞争和不一致性。常用的互斥机制包括锁（如互斥锁）和信号量等。</p>
</li>
<li><p>进程同步（Process Synchronization）是指在多个进程之间协调执行顺序和相互合作的机制。通过进程同步，可以确保进程按照一定的顺序执行，并且在某个进程需要依赖其他进程的执行结果时，能够等待该结果的完成。常见的进程同步机制包括信号量、条件变量、事件等。</p>
</li>
</ul>
<blockquote>
<p>进程互斥和同步是为了解决进程竞争和促进进程合作而引入的机制和概念。互斥保证了资源的独占性，避免竞争条件下的数据不一致性，而同步则确保了进程的有序执行和合作的有效性。</p>
</blockquote>
<h2 id="同步机构"><a href="#同步机构" class="headerlink" title="同步机构"></a>同步机构</h2><blockquote>
<p>锁和信号灯是计算机科学中用于同步多个进程或线程的机制。</p>
</blockquote>
<p><strong>锁（Lock）是一种互斥量（Mutex），用于保护共享资源的访问。</strong>当一个进程或线程获得了锁，其他进程或线程就无法同时访问被锁保护的资源，它们必须等待锁的释放。这样可以确保在同一时间只有一个进程或线程能够执行关键部分的代码，避免出现竞态条件（Race Condition）和数据不一致的问题。常见的锁包括互斥锁（Mutex）和读写锁（ReadWrite Lock）。</p>
<p><strong>信号灯（Semaphore）是一种计数器，用于控制对资源的访问。</strong>与锁不同，信号灯可以允许多个进程或线程同时访问被保护的资源，但需要根据信号灯的计数进行控制。每次一个进程或线程访问资源时，它会递减信号灯的计数。当计数减到零时，信号灯会阻塞其他进程或线程的访问，直到有一个进程或线程释放资源并增加信号灯的计数。信号灯可以用于解决生产者-消费者问题、限制并发访问资源等场景。</p>
<ul>
<li>PV操作是一种对信号灯进行操作的方式，用于控制进程或线程的访问和释放资源。<ul>
<li>P操作（也称为wait操作或down操作）用于申请资源。它会检查信号灯的计数，如果计数大于0，则将计数减1，表示资源被占用。如果计数为0，则该进程或线程会被阻塞，直到有其他进程或线程释放资源为止。</li>
<li>V操作（也称为signal操作或up操作）用于释放资源。它会将信号灯的计数加1，表示资源可用。如果有其他进程或线程正在等待该资源，它们会被唤醒并继续执行。</li>
</ul>
</li>
</ul>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>生产者-消费者问题是一种同步问题的抽象描述</p>
<p>问题的设定如下：</p>
<ul>
<li>有一个缓冲区用于存储生产者生成的数据项，生产者将数据项放入缓冲区</li>
<li>而消费者则从缓冲区中取出数据项进行处理。</li>
<li>生产者和消费者之间需要进行合作和同步，以确保缓冲区的正确访问和数据的有效处理。</li>
</ul>
<p>解决生产者-消费者问题的关键是使用适当的同步机制（例如信号灯、锁、条件变量等）来实现生产者和消费者之间的合作和互斥</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信是指在操作系统中，多个独立执行的进程之间进行信息交换和共享数据的机制。进程通信允许不同进程之间进行协作、协调和共享资源，以实现更复杂的任务和功能。</p>
<p>常见的进程通信机制：</p>
<ol>
<li>管道（Pipe）：管道是一个单向的字节流通道，可以用于在具有亲缘关系的两个进程之间进行通信。一个进程可以将数据写入管道，另一个进程可以从管道中读取数据。</li>
<li>消息队列（Message Queue）：消息队列是一种在进程之间传递消息的通信方式。进程可以将消息发送到消息队列，并由其他进程从队列中读取消息。</li>
<li>共享内存（Shared Memory）：共享内存允许多个进程共享同一块物理内存区域，进程可以直接读写这块共享内存来进行通信。这种方式效率高，但需要注意进程间的同步和互斥问题。</li>
<li>信号量（Semaphore）：信号量是一种计数器，用于控制多个进程对共享资源的访问。它可以用于进程之间的互斥和同步操作。</li>
<li>套接字（Socket）：套接字是一种在网络环境中进行进程间通信的机制。它允许不同主机上的进程进行通信，通过网络传输数据。</li>
</ol>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><p>资源是指计算机系统中可供进程使用的实体或服务。</p>
<p>资源可以是硬件资源（如处理器、内存、硬盘、输入输出设备）或软件资源（如文件、信号量、套接字）。</p>
<p>资源是系统中有限的，进程需要通过适当的机制进行管理和分配。</p>
<blockquote>
<p>资源管理的目的是优化资源的分配和利用，提高系统的性能、效率、公平性和安全性，以满足进程的需求，并确保系统能够稳定运行。</p>
</blockquote>
<h2 id="资源分配策略"><a href="#资源分配策略" class="headerlink" title="资源分配策略"></a>资源分配策略</h2><p>资源分配策略是指操作系统在管理和分配系统中有限资源时所采用的策略或算法。这些策略旨在合理地分配资源，以最大化系统的利用率、性能和公平性。不同的资源类型和应用场景可能需要不同的资源分配策略。以下是几种常见的资源分配策略：</p>
<ol>
<li>先来先服务（First-Come-First-Served，FCFS）：按照请求的先后顺序分配资源。先到达的请求先得到资源，后续请求需要等待前面的请求完成后才能获得资源。</li>
<li>最短作业优先（Shortest Job First，SJF）：根据任务或作业的执行时间长度来分配资源。执行时间最短的任务优先获得资源，以减少平均等待时间和执行时间。</li>
<li>优先级调度（Priority Scheduling）：为每个进程或任务分配一个优先级，并根据优先级的高低来分配资源。优先级较高的进程优先获得资源，以确保高优先级任务的及时执行。</li>
<li>轮转调度（Round Robin Scheduling）：将可分配资源按照一定时间片轮流分配给不同的进程。每个进程按照时间片大小获得资源，当时间片用完后，切换到下一个进程，以实现公平的资源分配。</li>
<li>抢占式调度（Preemptive Scheduling）：当一个进程正在使用资源时，具有更高优先级的进程可以抢占资源，并立即获得资源。这种策略允许系统根据实时需求动态地调整资源分配。</li>
</ol>
<p>这些资源分配策略都有其特定的应用场景和优劣势，选择合适的策略取决于系统的需求和约束。操作系统需要根据资源的特性和使用情况来制定适当的资源分配策略，以实现资源的有效管理和利用。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁（Deadlock）是指在多个进程或线程之间，每个进程都在等待其他进程释放某个资源，而导致所有进程都无法继续执行的一种状态。</p>
<p>死锁产生的必要条件是：</p>
<ol>
<li>互斥条件（Mutual Exclusion）：至少有一个资源被设计为只能被一个进程同时使用，即同一时间只能被一个进程占有。</li>
<li>占有并等待条件（Hold and Wait）：进程已经占有了至少一个资源，并且正在等待获取其他进程占有的资源。</li>
<li>不可剥夺条件（No Preemption）：已经分配给进程的资源不能被强制性地剥夺，只能在进程主动释放资源后才能被其他进程获取。</li>
<li>循环等待条件（Circular Wait）：存在一个进程的资源请求链，使得每个进程都在等待下一个进程所占有的资源。</li>
</ol>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>银行家算法的基本思想是，在系统中有多个进程和多种类型的资源。每个进程在运行之前必须申请所需的资源，并在使用完毕后释放资源。银行家算法根据进程的资源需求和系统中的可用资源进行安全性检查，以避免死锁的发生。</p>
<p>算法的主要步骤如下：</p>
<ol>
<li>初始化：确定系统中的资源数量和每个进程对资源的最大需求。</li>
<li>安全性检查：根据当前系统资源分配和每个进程的最大需求，计算出系统的安全序列，即一种分配资源的顺序，使得所有进程都能完成并避免死锁。</li>
<li>请求资源：当进程请求资源时，银行家算法会判断分配资源后是否仍然可以得到一个安全序列。如果是，则分配资源；否则，进程必须等待，直到满足安全条件。</li>
<li>释放资源：进程使用完资源后，将资源释放，使其可供其他进程使用。</li>
</ol>
<p>银行家算法的核心是安全性检查，通过预先计算系统的安全序列，确保在分配资源后不会进入死锁状态。如果系统中不存在安全序列，则不进行资源分配，以避免死锁的发生。</p>
<h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><p>​	处理机调度是指操作系统中的一种重要功能，用于决定在多道程序环境下，将处理机（CPU）分配给不同的进程或线程执行的顺序和时间。<strong>当有多个进程或线程同时需要执行时，处理机调度算法会决定哪个进程或线程获得CPU的使用权，以确保系统资源的合理利用和任务的高效执行。</strong>常见的作业调度算法如下：</p>
<ol>
<li>先来先服务（FCFS）：按照作业提交的顺序进行调度，先提交的作业先执行。</li>
<li>最短作业优先（SJF）：根据作业的执行时间，选择估计执行时间最短的作业先执行。</li>
<li>最高响应比优先（HRRN）：根据作业的等待时间和执行时间，计算作业的响应比，选择响应比最高的作业先执行。响应比定义为(等待时间+执行时间) &#x2F; 执行时间。</li>
<li>优先级调度：为每个作业分配优先级，根据优先级的高低选择作业执行顺序。可以是静态优先级，由系统管理员或作业本身指定；也可以是动态优先级，根据作业的某些属性或历史表现自动计算。</li>
<li>时间片轮转（Round Robin）：给每个作业分配一个固定的时间片，按照轮转的方式进行调度，每个作业执行一个时间片后，切换到下一个作业。</li>
<li>多级反馈队列调度：将作业划分为多个优先级队列，每个队列拥有不同的时间片大小或调度策略。作业开始在最高优先级队列执行，如果时间片用完还未完成，则被移到下一个较低优先级队列中。</li>
</ol>
<h1 id="主存管理"><a href="#主存管理" class="headerlink" title="主存管理"></a>主存管理</h1><p>主存管理的主要功能包括：</p>
<ol>
<li><strong>内存分配</strong>：主存管理负责将可用的内存空间划分为不同的区域，并为进程分配所需的的内存空间，也可以是动态的，在进程运行时根据需要动态调整内存大小。</li>
<li><strong>地址映射</strong>：主存管理通过地址映射将进程的逻辑地址转换为物理地址。每个进程都有自己的虚拟地址空间，主存管理负责将虚拟地址映射到实际的物理内存地址，以实现进程间的隔离和保护。</li>
<li>内存保护：主存管理通过内存保护机制，确保每个进程只能访问自己被分配的内存空间，防止进程之间相互干扰或访问不属于自己的内存区域。</li>
<li>内存回收：当进程终止或释放内存时，主存管理负责回收已使用的内存空间，并将其标记为可用状态，以供其他进程使用。内存回收可以是手动的，由进程显式释放，也可以是自动的，由操作系统检测到进程终止后自动回收。</li>
<li>内存碎片整理：主存管理负责解决内存碎片问题，包括外部碎片和内部碎片。外部碎片指的是由于内存分配和释放的不连续导致的一些零散的未分配内存空间，内部碎片则是指进程分配的内存空间中未被完全利用的部分。内存管理可以通过内存 compaction（内存压缩）等技术来整理内存，以提高内存利用率。</li>
</ol>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>虚拟存储器是一种计算机内存管理技术，它允许操作系统将物理内存（RAM）与辅助存储器（通常是硬盘）结合使用，从而扩展可用的内存空间。</p>
<p>每个进程都有自己的虚拟地址空间，这个地址空间通常比物理内存的大小要大。当进程执行时，它只需将当前需要的数据和指令加载到物理内存中，而不必将整个进程加载到内存。这样可以节省内存空间并提高系统的性能。</p>
<h2 id="主存映射"><a href="#主存映射" class="headerlink" title="主存映射"></a>主存映射</h2><p>用于将逻辑地址（也称为虚拟地址）映射到物理地址。逻辑地址是由进程生成的地址，而物理地址是实际的硬件内存地址。</p>
<p>通常，地址映射涉及两个级别的页表：一级页表和二级页表。一级页表将逻辑地址的高位部分映射到二级页表的物理地址。二级页表再将逻辑地址的低位部分映射到物理地址的页框。通过多级页表结构，可以有效地管理大型地址空间并减少页表的大小。</p>
<h2 id="分区主存管理"><a href="#分区主存管理" class="headerlink" title="分区主存管理"></a>分区主存管理</h2><p>用于将物理内存划分为多个固定大小的分区或区域，以容纳不同进程或任务的内存需求。</p>
<p>在分区存储管理中，物理内存被划分为若干个连续的区域，每个区域称为一个分区。每个分区可以被分配给一个进程或任务使用，以存储其数据、指令和堆栈等信息。</p>
<blockquote>
<p>分区存储管理的优点是简单且易于实现，它提供了一种有效的内存管理方式，使得多个进程可以同时运行而不互相干扰。然而，它也存在一些限制，如内存碎片问题，即空闲内存被分割成多个小块，无法满足大内存请求的情况。为了解决内存碎片问题，还可以使用压缩、合并或换页等技术。</p>
</blockquote>
<h2 id="页式存储"><a href="#页式存储" class="headerlink" title="页式存储"></a>页式存储</h2><p>在页式存储管理中，进程的地址空间被划分为固定大小的页，通常是以2的幂次方大小（如4KB或8KB）。物理内存也被划分为相同大小的物理页框。每个进程的地址空间由多个页组成，这些页被映射到物理内存的页框上。</p>
<p>页表是用于存储页的映射关系的数据结构。每个进程都有自己的页表，它记录了逻辑页和物理页框之间的映射关系。当进程访问内存时，使用逻辑地址查询页表，从而确定对应的物理页框。逻辑地址由页号和页内偏移量组成，其中页号表示页的索引，页内偏移量表示页内的偏移位置。</p>
<h2 id="段式存储"><a href="#段式存储" class="headerlink" title="段式存储"></a>段式存储</h2><p>段式存储管理是一种计算机内存管理技术，它将进程的地址空间划分为多个段，每个段具有逻辑上相关的一组数据或代码。每个段都被赋予一个唯一的标识符，称为段号。</p>
<p>在段式存储管理中，每个段的大小是可变的，根据进程的需要进行分配。不同的段可以具有不同的大小，并且可以根据进程的需求进行动态扩展或缩小。</p>
<p>段表是用于存储段的映射关系的数据结构。每个进程都有自己的段表，段表记录了逻辑段号和物理内存地址之间的映射关系。当进程访问内存时，使用逻辑地址的段号查询段表，从而确定对应的物理内存地址。</p>
<h1 id="输入输出管理"><a href="#输入输出管理" class="headerlink" title="输入输出管理"></a>输入输出管理</h1><p>输入输出（I&#x2F;O）管理是计算机系统中负责处理和控制输入和输出设备的一组软件和硬件组件。</p>
<p>输入输出管理的目标是实现高效、可靠和安全的数据传输，并提供方便的接口和操作方式，使应用程序能够与外部设备进行通信和交互。</p>
<p>输入输出管理涉及以下几个方面的功能和任务：</p>
<ol>
<li>设备驱动程序：设备驱动程序是与特定设备硬件通信的软件组件。它负责与设备进行交互，控制设备的操作，发送命令和接收数据。</li>
<li>缓冲管理：输入输出管理使用缓冲区来存储输入和输出数据，以平衡处理器和设备之间的速度差异。缓冲管理负责管理缓冲区的分配、管理和数据传输，以提高数据传输效率。</li>
<li>设备分配和调度：输入输出管理需要协调多个进程对设备的请求，并分配设备资源给不同的进程。设备调度算法决定了进程访问设备的顺序，以最大程度地提高设备利用率和响应时间。</li>
<li>错误处理：输入输出管理需要处理可能发生的各种错误，如设备故障、数据传输错误和中断处理等。它会监测和处理错误情况，保证系统的可靠性和稳定性。</li>
<li>设备独立性：输入输出管理提供设备独立性的抽象层，使应用程序不需要关心具体的设备细节。通过设备驱动程序和标准化的接口，应用程序可以以统一的方式与不同类型的设备进行通信。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lw-maple.github.io">Lost丶逝水如风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lw-maple.github.io/2022/11/19/2022-11-20-%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91/">https://lw-maple.github.io/2022/11/19/2022-11-20-【操作系统】/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lw-maple.github.io" target="_blank">漫漫长夜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="/img/coverImg/0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/12/2023-3-12-%E3%80%90Blog%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91/"><img class="prev-cover" src="/img/coverImg/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">博客项目总结</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/19/2022-10-19-%E3%80%90Nginx%E3%80%91/"><img class="next-cover" src="/img/coverImg/15.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Nginx</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">操作系统的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统的资源管理功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统的特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-number">2.</span> <span class="toc-text">存储式计算机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">存储式计算机的结构和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.</span> <span class="toc-text">计算机系统结构和操作系统之间的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">操作系统的发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.1.</span> <span class="toc-text">批量操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.</span> <span class="toc-text">分时操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.3.</span> <span class="toc-text">实时操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.</span> <span class="toc-text">网络操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.5.</span> <span class="toc-text">分布式操作系统</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">操作系统的组织结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E7%8A%B6%E6%80%81%E5%8F%8A%E5%88%86%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">处理机状态及分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4"><span class="toc-number">5.1.</span> <span class="toc-text">特权指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">6.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">中断分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">7.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">7.1.1.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">7.1.2.</span> <span class="toc-text">进程控制块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">7.3.</span> <span class="toc-text">进程之间的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E6%9E%84"><span class="toc-number">7.4.</span> <span class="toc-text">同步机构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">7.5.</span> <span class="toc-text">生产者-消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">7.6.</span> <span class="toc-text">进程通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">8.1.</span> <span class="toc-text">资源分配策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">8.2.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">银行家算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">9.</span> <span class="toc-text">处理机调度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">主存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">10.1.</span> <span class="toc-text">虚拟存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">10.2.</span> <span class="toc-text">主存映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E4%B8%BB%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">10.3.</span> <span class="toc-text">分区主存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">10.4.</span> <span class="toc-text">页式存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">10.5.</span> <span class="toc-text">段式存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">输入输出管理</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lost丶逝水如风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
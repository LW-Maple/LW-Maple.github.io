<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Nginx | 漫漫长夜</title><meta name="keywords" content="Nginx"><meta name="author" content="Lost丶逝水如风"><meta name="copyright" content="Lost丶逝水如风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Nginx介绍Nginx是什么?Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx">
<meta property="og:url" content="https://lw-maple.github.io/2022/10/19/2022-10-19-%E3%80%90Nginx%E3%80%91/index.html">
<meta property="og:site_name" content="漫漫长夜">
<meta property="og:description" content="Nginx介绍Nginx是什么?Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lw-maple.github.io/img/coverImg/15.jpg">
<meta property="article:published_time" content="2022-10-19T07:41:28.000Z">
<meta property="article:modified_time" content="2022-11-19T01:31:49.422Z">
<meta property="article:author" content="Lost丶逝水如风">
<meta property="article:tag" content="Nginx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lw-maple.github.io/img/coverImg/15.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lw-maple.github.io/2022/10/19/2022-10-19-%E3%80%90Nginx%E3%80%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/img/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Nginx',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-19 09:31:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/self/atom-one-dark.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GJ411x7h7"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/coverImg/15.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">漫漫长夜</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GJ411x7h7"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Nginx</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-19T07:41:28.000Z" title="发表于 2022-10-19 15:41:28">2022-10-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-19T01:31:49.422Z" title="更新于 2022-11-19 09:31:49">2022-11-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Nginx/">Nginx</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Nginx"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h1><h2 id="Nginx是什么"><a href="#Nginx是什么" class="headerlink" title="Nginx是什么?"></a>Nginx是什么?</h2><p><strong>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器</strong>，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p>
<p>其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<ul>
<li>正向代理</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.5u72na7a9hc0.webp"></p>
<ul>
<li>反向代理</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.3622anezbxi0.webp"></p>
<p>正向代理的 Proxy 是多对一，反向代理的 Proxy 是一对多。</p>
<p>反向代理是代理服务端，对外暴露反向代理服务器的IP，不暴露真实服务器的IP，客户端发送请求到反向代理服务器，反向代理服务器自己去找真正的服务端。</p>
<h2 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h2><ul>
<li><strong>速度更快、并发更高速度更快、并发更高</strong></li>
</ul>
<p>单次请求或者高并发请求的环境下，Nginx 都会比其他 Web 服务器响应的速度更快。一方面在正常情况下，单次请求会得到更快的响应，另一方面，在高峰期(如有数以万计的并发请求)，Nginx 比其他 Web 服务器更快的响应请求。Nginx 之所以有这么高的并发处理能力和这么好的性能原因在于 Nginx 采用了多进程和 I&#x2F;O 多路复用(epoll)的底层实现。</p>
<ul>
<li><strong>配置简单，扩展性强</strong></li>
</ul>
<p>Nginx 的设计极具扩展性，它本身就是由很多模块组成，这些模块的使用可以通过配置文件的配置来添加。这些模块有官方提供的也有第三方提供的模块，如果需要完全可以开发服务自己业务特性的定制模块</p>
<ul>
<li><strong>高可靠性</strong></li>
</ul>
<p>Nginx 采用的是多进程模式运行，其中有一个 master 主进程和 N 多个 worker 进程，一个 master 管理多个 worker，worker 进程的数量我们可以手动设置，每个 worker 进程之间都是相互独立提供服务，并且 master 主进程可以在某一个 worker 进程出错时，快速去「拉起」新的 worker 进程提供服务。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220727/image.3wz8th685620.webp" alt="image"></p>
<ul>
<li><strong>热部署(核心)</strong></li>
</ul>
<p>现在互联网项目都要求以 7 * 24 小时进行服务的提供，针对于这一要求，Nginx 也提供了热部署功能，即可以在 Nginx 不停止的情况下，对 Nginx 进行文件升级、更新配置和更换日志文件等功能。</p>
<ul>
<li><strong>成本低、BSD许可证</strong></li>
</ul>
<p>BSD 是一个开源的许可证，世界上的开源许可证有很多，现在比较流行的有六种分别是 GPL、BSD、MIT、Mozilla、Apache、LGPL。</p>
<blockquote>
<p>Nginx 提供的基本功能服务从大体上归纳为「基本 HTTP 服务」、「高级 HTTP 服务」和「邮件服务」等三大类。</p>
</blockquote>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><table>
<thead>
<tr>
<th align="center">选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-? 和 -h</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td align="center">-v</td>
<td>打印版本号信息并退出</td>
</tr>
<tr>
<td align="center">-V</td>
<td>打印版本号信息和配置信息并退出</td>
</tr>
<tr>
<td align="center">-t</td>
<td>测试 Nginx 的配置文件语法是否正确并退出</td>
</tr>
<tr>
<td align="center">-T</td>
<td>测试 Nginx 的配置文件语法是否正确并列出用到的配置文件信息然后退出</td>
</tr>
<tr>
<td align="center">-q</td>
<td>在配置测试期间过滤掉非错误消息</td>
</tr>
<tr>
<td align="center">-s</td>
<td>signal 信号，后面的命令和服务信号控制功能类似： <code>stop</code>：快速关闭，类似于 TERM&#x2F;INT 信号的作用 <code>quit</code>：优雅的关闭，类似于 QUIT 信号的作用 <code>reopen</code>：重新打开日志文件类似于 USR1 信号的作用 <code>reload</code>：重启 Nginx，类似于 HUP 信号的作用</td>
</tr>
<tr>
<td align="center">-p</td>
<td>prefix，指定 Nginx 的默认安装路径，(默认为：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;)</td>
</tr>
<tr>
<td align="center">-c</td>
<td>filename，指定 Nginx 的配置文件路径,(默认为：conf&#x2F;nginx.conf)</td>
</tr>
<tr>
<td align="center">-g</td>
<td>用来补充 Nginx 配置文件，向 Nginx 服务指定启动时应用全局的配置</td>
</tr>
</tbody></table>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>Nginx配置文件的位置：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf。<br>将Nginx的配置文件分为三部分：<strong>全局块、events块、http块</strong>。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;   <span class="hljs-comment"># 指令用于配置 Nginx 生成 worker 工作进程的数量，这个是 Nginx 服务器实现并发处理服务的关键所在。 </span><br><br><span class="hljs-section">events</span> &#123;    <span class="hljs-comment"># 这是 events 块</span><br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;    <span class="hljs-comment"># 这是 http 块</span><br>    <span class="hljs-attribute">include</span>       mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;   <span class="hljs-comment"># 监听 80 端口</span><br>        <span class="hljs-attribute">server_name</span>  localhost;   <span class="hljs-comment"># 监听请求过来的 IP</span><br>        <span class="hljs-section">location</span> / &#123;   <span class="hljs-comment"># 请求的地址是 /，则进入这个配置，访问 idnex.html</span><br>            <span class="hljs-attribute">root</span>   html;      <span class="hljs-comment"># 进入 html 目录找到访问的页面</span><br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        &#125;<br>        <span class="hljs-comment"># 如果访问的页面是 500 502 503 504，则发送 /50x.html 请求</span><br>        <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;  <br>        <span class="hljs-section">location</span> = /50x.html &#123;      <span class="hljs-comment"># 如果匹配上 /50x.html 请求</span><br>            <span class="hljs-attribute">root</span>   html;     <span class="hljs-comment"># 则进入 html 目录找到 /50x.html</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h2><ul>
<li>从配置文件开始到events块之间的内容，主要会设置一些影响Nginx服务器整体运行的配置指令，主要包括配置运行Nginx服务器的用户（组）、允许生成的worker process数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等。</li>
</ul>
<h2 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h2><ul>
<li><p>events块涉及的指令主要影响Nginx服务器与用户的网络连接，常用的设置包括是否开启对多worker process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个worker process可以同时支持的最大连接数等。<br>这部分对Nginx的性能影响较大，实际中需要灵活配置。</p>
</li>
<li><p>events指令</p>
<p><code>accept_mutex</code> 指令用来设置是否开启 Nginx 网络连接序列化。默认开启。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>语法</th>
<th>默认值</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>accept_mutex &lt;on | off&gt;;</td>
<td>accept_mutex on;</td>
<td>events</td>
</tr>
</tbody></table>
<p>这个配置主要可以用来解决常说的「惊群」问题。大致意思是在某一个时刻，客户端发来一个请求连接，Nginx 后台是以多进程的工作模式，也就是说有多个 worker 进程会被同时唤醒，但是最终只会有一个进程可以获取到连接，如果每次唤醒的进程数目太多，就会影响 Nginx 的整体性能。如果将上述值设置为 on (开启状态)，将会对多个 Nginx 进程接收连接进行序列号，一个个来唤醒接收，就防止了多个进程对连接的争抢。</p>
<p>如图的小狗，如果只是一块「骨头」出现，则只需要唤醒一个小狗即可（开启 on），如果多个「骨头」如三个同时出现，那么唤醒三个小狗效率更高（此时需要设置 off）</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220728/image.118zwwf8v268.webp"></p>
<h2 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h2><p>http块是Nginx中使用最频繁的部分。http块包括http全局块和server块。</p>
<ul>
<li><p>http全局块配置的指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等。</p>
<ul>
<li>我们都知道浏览器中可以显示的内容有 HTML、XML、GIF 等种类繁多的文件、媒体等资源，浏览器为了区分这些资源，就需要使用 MIME Type。</li>
<li>所以说 MIME Type 是网络资源的媒体类型。Nginx 作为 Web 服务器，也需要能够识别前端请求的资源类型。</li>
</ul>
</li>
<li><p>server块和虚拟主机有密切关系，每个http块可以包含多个server块，每个server块相当于一个虚拟主机。每个server块又包含server全局块、多个location块。</p>
<ul>
<li>server全局块用于虚拟机监听配置，虚拟主机名称和IP配置。</li>
<li>loaction块基于Nginx服务器接收到的请求路径，对虚拟主机以外的路径进行匹配，对特定请求进行特定处理</li>
</ul>
</li>
</ul>
<h1 id="静态资源部署与访问"><a href="#静态资源部署与访问" class="headerlink" title="静态资源部署与访问"></a>静态资源部署与访问</h1><ul>
<li><strong>静态资源与动态资源</strong></li>
</ul>
<p>上网去搜索访问资源对于我们来说并不陌生，通过浏览器发送一个 HTTP 请求实现从客户端发送请求到服务器端获取所需要内容后并把内容回显展示在页面的一个过程。这个时候，我们所请求的内容就分为两种类型，一类是静态资源、一类是动态资源。</p>
<p><strong>静态资源</strong>即指在服务器端真实存在并且能直接拿来展示的一些文件，比如常见的 html 页面、css 文件、js 文件、图片、视频等资源；</p>
<p><strong>动态资源</strong>即指在服务器端真实存在但是要想获取需要经过一定的业务逻辑处理，根据不同的条件展示在页面不同这 一部分内容，比如说报表数据展示、根据当前登录用户展示相关具体数据等资源；</p>
<ul>
<li><p><strong>静态资源优化</strong></p>
<ul>
<li>&#96;&#96;&#96;nginx<br>sendfile on;#该指令是用来开启高效的文件传输模式。默认关闭，建议开启。<br>tcp_nopush on;#该指令必须在 sendfile 打开的状态下才会生效，主要是用来提升网络包的传输「效率」。默认关闭。<br>tcp_nodeplay on;#该指令必须在 keep-alive 连接开启的情况下才生效，来提高网络包传输的「实时性」。默认开启。<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">  -</span> &gt; 经过分析，『 tcp<span class="hljs-emphasis">_nopush 』和『 tcp_</span>nodelay 』看起来是「互斥的」，那么为什么要将这两个值都打开?<br><span class="hljs-code">    &gt;</span><br><span class="hljs-code">    &gt; 需要知道的是在 Linux2.5.9 以后的版本中两者是可以兼容的</span><br><span class="hljs-code">    &gt;</span><br><span class="hljs-code">    &gt; - 『 tcp_nopush 』开启可以确保在发送到客户端之前数据包已经充分「填满」，这大大减少了网络开销，并加快了文件发送的速度。</span><br><span class="hljs-code">    &gt;</span><br><span class="hljs-code">    &gt; - 当它到达最后一个可能因为没有「填满」而暂停的数据包时，Nginx 会忽略『 tcp_nopush 』参数， 『 tcp_nodelay 』强制套接字发送数据。</span><br><span class="hljs-code">    &gt;</span><br><span class="hljs-code">    &gt; 由此可知，『 tcp_nopush 』可以与『 tcp_nodelay 』一起设置，它比单独配置『 tcp_nodelay 』具有更强的性能。</span><br><span class="hljs-code"></span><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**静态资源压缩**</span><br><br><span class="hljs-bullet">  -</span> 我们传送一个 1M 的数据和一个 10M 的数据那个效率高？答案显而易见，<span class="hljs-strong">**传输内容小，速度就会快**</span>。那么问题又来了，同样的内容，如果把大小降下来，我们脑袋里面要蹦出一个词就是「压缩」<br><span class="hljs-bullet">  -</span> 在 Nginx 的配置文件中可以通过配置 gzip 来对静态资源进行压缩，相关的指令可以配置在 http 块、server 块和 location 块中，Nginx 可以通过对这些指令进行解析和处理：<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`ngx_http_gzip_module`</span> 模块<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`ngx_http_gzip_static_module`</span> 模块<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`ngx_http_gunzip_module`</span> 模块<br><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**静态资源缓存**</span><br><br><span class="hljs-bullet">  -</span> 当浏览器请求 Nginx 服务器的资源后，我们可以让这些资源缓存在浏览器里，这样再一次请求相同的资源时，无需请求 Nginx 服务器，直接从浏览器的缓存里获取，减少 Nginx 服务器的压力。<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">`expires`</span>指令用来控制页面缓存的作用。可以通过该指令控制 HTTP 应答中的『Expires』和『Cache-Control』<br><br><span class="hljs-bullet">  -</span> 可在配置文件进行配置<br><br><span class="hljs-bullet">    -</span> <span class="hljs-code">```nginx</span><br><span class="hljs-code">      location ~ .*\.(html|js|css|png|jpg|jpeg|gif)$ &#123;</span><br><span class="hljs-code">          # ...</span><br><span class="hljs-code">          expires max</span><br><span class="hljs-code">          # ...</span><br><span class="hljs-code">      &#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>&#96;&#96;&#96;nginx<br>expires 30s;  # 表示把数据缓存 30 秒</p>
<p>expires 30m;  # 表示把数据缓存 30 分</p>
<p>expires 10h;  # 表示把数据缓存 10 小时</p>
<p>expires 1d;   # 表示把数据缓存 1 天</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><br><span class="hljs-meta"># 反向代理</span><br><br><span class="hljs-meta">## proxy_pass</span><br><br>该指令用来设置被代理服务器地址，可以是主机名称、IP 地址加端口号形式，没有默认值。<br><br><span class="hljs-string">| 语法              | 默认值 | 位置     |</span><br><span class="hljs-string">| ----------------- | ------ | -------- |</span><br><span class="hljs-string">| proxy_pass &lt;URL&gt;; | —      | location |</span><br><br>`URL`：为要设置的被代理服务器地址，包含传输协议(`http`、`https:<span class="hljs-comment">//`)、主机名称或 IP 地址加端口号</span><br><br>准备两台服务器或者按照 Linux 系统的虚拟机，这里是 `<span class="hljs-number">192.168</span>.<span class="hljs-number">200.133</span>` 和 `<span class="hljs-number">192.168</span>.<span class="hljs-number">200.146</span>`，为了方便，我们称前者为服务器 A，后者为服务器 B。<br><br>```nginx<br>server &#123;<br>	listen <span class="hljs-number">80</span>;<br>	server_name localhost;<br>	location / &#123;<br>        <span class="hljs-meta"># 下面两个地址加不加斜杠，效果都一样，因为 location 后的 / 会添加在代理地址后面</span><br>		proxy_pass http:<span class="hljs-comment">//192.168.200.146;</span><br>		proxy_pass http:<span class="hljs-comment">//192.168.200.146/;</span><br>	&#125;<br>&#125;<br><span class="hljs-meta"># 当客户端请求服务器 A http:<span class="hljs-comment">//192.168.200.133，它会转发给服务器 B，此时的服务器 A 就是一个代理的角色。</span></span><br><br>server&#123;<br>	listen <span class="hljs-number">80</span>;<br>	server_name localhost;<br>	location /server &#123;<br>        <span class="hljs-meta"># 下面两个地址必须加斜杠，因为 location 后的 /server 会添加在代理地址后面，第一个将没有 / 结尾</span><br>		<span class="hljs-meta">#proxy_pass http:<span class="hljs-comment">//192.168.200.146;</span></span><br>		proxy_pass http:<span class="hljs-comment">//192.168.200.146/;</span><br>	&#125;<br>&#125;<br><span class="hljs-meta"># 上面的 location：当客户端访问 http:<span class="hljs-comment">//localhost/server/index.html</span></span><br><span class="hljs-meta"># 第一个 proxy_pass 就变成了 http:<span class="hljs-comment">//localhost/server/index.html</span></span><br><span class="hljs-meta"># 第二个 proxy_pass 就变成了 http:<span class="hljs-comment">//localhost/index.html 效果就不一样了。</span></span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果不以 <code>/</code> 结尾，则 location 后的 <code>/server</code> 会添加在地址后面，所以第一个 proxy_pass 因为没有 <code>/</code> 结尾而被加上 <code>/server</code>，</p>
<p>而第二个自带了 <code>/</code> ，所以不会添加 <code>/server</code>。</p>
</blockquote>
<p>上面的例子仅仅针对：访问任意请求如 <code>/server</code> 时，想要代理到其他服务器的首页，则加 <code>/</code>，</p>
<p>否则你如果真的想访问 <code>/server</code> 下的资源，那么不要加 <code>/</code>。</p>
<h2 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a>proxy_set_header</h2><p>该指令可以更改 Nginx 服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器。默认值是发送代理服务器的地址和 close。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.4bt7qzhbz1i0.webp"><strong>服务器A配置：</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>  <span class="hljs-number">8080</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <span class="hljs-section">location</span> /server &#123;           <span class="hljs-comment"># 访问 /server 触发代理</span><br>        <span class="hljs-attribute">proxy_pass</span> http://192.168.200.146:8080/;  <span class="hljs-comment"># 配置服务器 B 的地址</span><br>        <span class="hljs-attribute">proxy_set_header</span> username TOM;  <span class="hljs-comment"># 发送 key 为 username，value 为 TOM 的请求头给服务器 B</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>服务器B配置:</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>  <span class="hljs-number">8080</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <span class="hljs-attribute">default_type</span> text/plain;<br>    <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-variable">$http_username</span>;    <span class="hljs-comment"># 获取代理服务器发送过来的 http 请求头的 username 值</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>测试结果：</strong></p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.398ksbw6rv20.webp"></p>
<h2 id="proxy-redirect"><a href="#proxy-redirect" class="headerlink" title="proxy_redirect"></a>proxy_redirect</h2><p>该指令是用来重置头信息中的『 Location 』和『 Refresh 』的值，<strong>防止客户端可以看到被代理服务器的地址</strong>。</p>
<ul>
<li><strong>为什么要使用该指令？</strong></li>
</ul>
<p>首先说明一下思路：客户端通过代理服务器 A 访问服务器 B 的资源，但是服务器 B 不存在该资源，则会报错。此时我们不希望它直接返回报错页面给客户端，我们希望服务器 B 返回的是它的欢迎页面。那么如何做呢？</p>
<ul>
<li>首先在服务器 B 进行判断是否存在资源，不存在则返回自己的欢迎页面，即重定向到自己的欢迎页面地址并返回，此时浏览器的地址将会发生改变</li>
<li>代理服务器 A 收到服务器 B 的欢迎页面和地址，<strong>但是我们不能直接返回给客户端，因为它会暴露服务器 B 的地址</strong>，这是重定向的原因</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.a4tptcx6lbk.webp"></p>
<ul>
<li>此时用到 <code>proxy_redirect</code> 指令，重置服务器 B 返回过来的『 Location 』和『 Refresh 』值，将两个值改为代理服务器 A 的某个地址</li>
<li>因为改为了代理服务器 A 的某个地址，所以代理服务器 A 根据这个地址又去获取理服务器 B 的欢迎页面地址，返回给客户端</li>
</ul>
<p>总结：</p>
<ol>
<li>客户端通过 A 找 B 不存在的资源，B 不想返回报错页面，于是重定向到自己的欢迎页面地址并返回给 A。</li>
<li>A 收到了页面和地址（正常情况不要接收地址，只接收页面），发现不能暴露 B 的地址，于是修改接收的 B 的地址为自己的某一个地址。</li>
<li>这个地址会重新发送请求去获取 B 的欢迎页面地址，然后返回给客户端。</li>
</ol>
<p><strong>服务器B:</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>  <span class="hljs-number">8081</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <span class="hljs-attribute">if</span> (!-f <span class="hljs-variable">$request_filename</span>)&#123;<br>    	<span class="hljs-attribute">return</span> <span class="hljs-number">302</span> http://192.168.200.146;   <span class="hljs-comment">#  2.如果请求的资源不存在，则重定向到服务器 B</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>服务器A：</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>	<span class="hljs-attribute">listen</span>  <span class="hljs-number">8081</span>;<br>	<span class="hljs-attribute">server_name</span> localhost;<br>	<span class="hljs-section">location</span> / &#123;<br>		<span class="hljs-attribute">proxy_pass</span> http://192.168.200.146:8081/;  <span class="hljs-comment"># 1.转发给服务器 B</span><br>		<span class="hljs-attribute">proxy_redirect</span> http://192.168.200.146 http://192.168.200.133; <span class="hljs-comment"># 3.修改服务器 B 的地址</span><br>	&#125;<br>&#125;<br><span class="hljs-comment"># 该 server 去请求服务器 B 的欢迎页面</span><br><span class="hljs-section">server</span> &#123;<br>	<span class="hljs-attribute">listen</span>  <span class="hljs-number">80</span>;<br>	<span class="hljs-attribute">server_name</span> <span class="hljs-number">192.168.200.133</span>;<br>	<span class="hljs-section">location</span> / &#123;<br>		<span class="hljs-attribute">proxy_pass</span> http://192.168.200.146;  <span class="hljs-comment"># 4.重新发送请求给服务器 B，获取欢迎页面</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220802/image.59ecpsonzxc0.webp"></p>
<ul>
<li>当三台服务器内容不相同时</li>
<li>服务器有限，只能以三个端口模拟三台服务器，实际上是一个 IP 对应一个服务器</li>
</ul>
<p><strong>代理服务器:</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 代理服务器</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>  <span class="hljs-number">8082</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost; <br>    <span class="hljs-section">location</span> /server1 &#123;    <br>        <span class="hljs-attribute">proxy_pass</span> http://192.168.200.146:9001/;   <span class="hljs-comment"># 代理 server1</span><br>    &#125;<br>    <span class="hljs-section">location</span> /server2 &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://192.168.200.146:9002/;   <span class="hljs-comment"># 代理 server2</span><br>    &#125;<br>    <span class="hljs-section">location</span> /server3 &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://192.168.200.146:9003/;   <span class="hljs-comment"># 代理 server3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>服务器:</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 服务器</span><br><span class="hljs-comment"># server1</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>  <span class="hljs-number">9001</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-attribute">default_type</span> text/html;<br>    <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;&#x27;</span><br>&#125;<br><span class="hljs-comment"># server2</span><br>server &#123;<br>    <span class="hljs-attribute">listen</span>  <span class="hljs-number">9002</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-attribute">default_type</span> text/html;<br>    <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;&#x27;</span><br>&#125;<br><span class="hljs-comment"># server3</span><br>server &#123;<br>    <span class="hljs-attribute">listen</span>  <span class="hljs-number">9003</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-attribute">default_type</span> text/html;<br>    <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="均衡负载"><a href="#均衡负载" class="headerlink" title="均衡负载"></a>均衡负载</h1><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>准备四台服务器，一台用来做负载均衡器，三台用来接收负载均衡器的请求。</p>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220803/image.etsfgkwsxaw.webp" alt="image"></p>
<p>因为目前只有两台服务器，所以一台用来做负载均衡器，另外一台用来接收负载均衡器的请求。</p>
<p>服务器设置：这里以三个端口代替三个服务器，在配置文件进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 服务器 1</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>   <span class="hljs-number">9001</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <span class="hljs-attribute">default_type</span> text/html;<br>    <span class="hljs-section">location</span> /&#123;<br>    	<span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&lt;h1&gt;192.168.200.146:9001&lt;/h1&gt;&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment"># 服务器 2</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>   <span class="hljs-number">9002</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <span class="hljs-attribute">default_type</span> text/html;<br>    <span class="hljs-section">location</span> /&#123;<br>    	<span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&lt;h1&gt;192.168.200.146:9002&lt;/h1&gt;&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment"># 服务器 3</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>   <span class="hljs-number">9003</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <span class="hljs-attribute">default_type</span> text/html;<br>    <span class="hljs-section">location</span> / &#123;<br>    	<span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&lt;h1&gt;192.168.200.146:9003&lt;/h1&gt;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>负载均衡器设置：这是一个 Nginx 代理服务器，让它去负载均衡访问三个服务器，在配置文件进行如下配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backend&#123;<br>	<span class="hljs-attribute">server</span> <span class="hljs-number">192.168.200.146:9091</span>;<br>	<span class="hljs-attribute">server</span> <span class="hljs-number">192.168.200.146:9092</span>;<br>	<span class="hljs-attribute">server</span> <span class="hljs-number">192.168.200.146:9093</span>;<br>&#125;<br><span class="hljs-section">server</span> &#123;<br>	<span class="hljs-attribute">listen</span> <span class="hljs-number">8083</span>;<br>	<span class="hljs-attribute">server_name</span> localhost;<br>	<span class="hljs-section">location</span> / &#123;<br>		<span class="hljs-attribute">proxy_pass</span> http://backend;   <span class="hljs-comment"># backend 要对应上 upstream 后的值，根据需求修改</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>访问负载均衡器的地址，如 <code>http://192.168.200.133:8083</code>，它会找到 <code>proxy_pass</code> 后的地址，比如上方，它会根据 backend 找到对应的 upstream 里内地址，替换掉 backend，变成：</p>
<ul>
<li>proxy_pass <code>http://192.168.200.146:9091</code></li>
<li>proxy_pass <code>http://192.168.200.146:9092</code></li>
<li>proxy_pass <code>http://192.168.200.146:9093</code></li>
</ul>
<p>但是它不会全部访问三个服务器地址，而是根据自己的算法（轮询）选择其中一个服务器地址。</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>代理服务器在负责均衡调度中的状态有以下几个：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>down</td>
<td>当前的 server 暂时不参与负载均衡</td>
</tr>
<tr>
<td>backup</td>
<td>预留的备份服务器</td>
</tr>
<tr>
<td>max_fails</td>
<td>指令设置允许请求代理服务器失败的次数，默认为 1。</td>
</tr>
<tr>
<td>fail_timeout</td>
<td>指令设置经过 max_fails 失败后，服务暂停的时间，默认是 10 秒。</td>
</tr>
<tr>
<td>max_conns</td>
<td>限制最大的接收连接数</td>
</tr>
</tbody></table>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backend&#123;<br>	<span class="hljs-attribute">server</span> <span class="hljs-number">192.168.200.133:9001</span> down;//该服务不可用<br>	<span class="hljs-attribute">server</span> <span class="hljs-number">192.168.200.133:9002</span> backup;//当主服务器挂掉才使用<br>	<span class="hljs-attribute">server</span> <span class="hljs-number">192.168.200.133:9003</span> max_fails=<span class="hljs-number">3</span> fail_timeout=<span class="hljs-number">15</span>; <br>&#125;<br><span class="hljs-section">server</span> &#123;<br>	<span class="hljs-attribute">listen</span> <span class="hljs-number">8083</span>;<br>	<span class="hljs-attribute">server_name</span> localhost;<br>	<span class="hljs-section">location</span> /&#123;<br>		<span class="hljs-attribute">proxy_pass</span> http://backend;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="均衡负载策略"><a href="#均衡负载策略" class="headerlink" title="均衡负载策略"></a>均衡负载策略</h2><p>介绍完 Nginx 负载均衡的相关指令后，我们已经能实现将用户的请求分发到不同的服务器上，那么除了采用默认的分配方式以外，我们还能采用什么样的负载算法？</p>
<p>Nginx 的 upstream 支持如下六种方式的分配算法，分别是:</p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>轮询</td>
<td>默认方式</td>
</tr>
<tr>
<td>weight</td>
<td>权重方式</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据 IP 分配方式</td>
</tr>
<tr>
<td>least_conn</td>
<td>依据最少连接方式</td>
</tr>
<tr>
<td>url_hash</td>
<td>依据 URL 分配方式</td>
</tr>
<tr>
<td>fair</td>
<td>依据响应时间方式</td>
</tr>
</tbody></table>
<ul>
<li><p>轮询：这是 <code>upstream</code> 模块负载均衡默认的策略。每个请求会按时间顺序逐个分配到不同的后端服务器。轮询不需要额外的配置。</p>
<ul>
<li><p>&#96;&#96;&#96;nginx<br>upstream backend{<br>server 192.168.200.146:9001;<br>server 192.168.200.146:9002;<br>server 192.168.200.146:9003;<br>}<br>server {<br>listen 8083;<br>server_name localhost;<br>location &#x2F;{<br>    proxy_pass <a target="_blank" rel="noopener" href="http://backend/">http://backend</a>;<br>}<br>}</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- weight：`weight` 指令用来设置服务器的权重，默认为 <span class="hljs-number">1</span>，权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的，所有此策略比较适合服务器的硬件配置差别比较大的情况。<br><br>  - ```nginx<br>    upstream backend&#123;<br>    	<span class="hljs-keyword">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.146</span>:<span class="hljs-number">9001</span> weight=<span class="hljs-number">10</span>;<br>    	<span class="hljs-keyword">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.146</span>:<span class="hljs-number">9002</span> weight=<span class="hljs-number">5</span>;<br>    	<span class="hljs-keyword">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.200</span><span class="hljs-number">.146</span>:<span class="hljs-number">9003</span> weight=<span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">server</span> &#123;<br>    	<span class="hljs-keyword">listen</span> <span class="hljs-number">8083</span>;<br>    	server_name localhost;<br>    	<span class="hljs-keyword">location</span> /&#123;<br>    		proxy_pass http://backend;<br>    	&#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ip_hash: 当<code>ip_hash</code> 指令能够将某个客户端 IP 的请求通过哈希算法定位到同一台后端服务器上。这样，当来自某一个 IP 的用户在后端 Web 服务器 A 上登录后，在访问该站点的其他 URL，能保证其访问的还是后端 Web 服务器 A</p>
<p>总结：哪个服务器曾经处理过请求，无论在哪里，相同的请求依然让该服务器处理</p>
<ul>
<li><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220804/image.7a0ysgphfxg0.webp" alt="image"></li>
</ul>
</li>
<li><p>least_conn: 最少连接数，把请求转发给连接数较少的后端服务器。</p>
</li>
<li><p>url_hash: 按访问 URL 的 hash 结果来分配请求，使每个 URL 定向到同一个后端服务器，要配合缓存命中来使用。</p>
</li>
<li><p>fair: <code>fair</code> 指令采用的不是内建负载均衡使用的轮换的均衡算法，而是可以根据页面大小、加载时间长短智能的进行负载均衡。</p>
<ul>
<li>但是这样直接使用会报错，因为 fair 属于第三方模块实现的负载均衡。需要添加 <code>nginx-upstream-fair</code> 模块</li>
</ul>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backend&#123;<br>	ip_hash;<span class="hljs-comment">#//least_conn;//hash &amp;request_uri;//fair;</span><br>	<span class="hljs-attribute">server</span> <span class="hljs-number">192.168.200.146:9001</span>;<br>	<span class="hljs-attribute">server</span> <span class="hljs-number">192.168.200.146:9002</span>;<br>	<span class="hljs-attribute">server</span> <span class="hljs-number">192.168.200.146:9003</span>;<br>&#125;<br><span class="hljs-section">server</span> &#123;<br>	<span class="hljs-attribute">listen</span> <span class="hljs-number">8083</span>;<br>	<span class="hljs-attribute">server_name</span> localhost;<br>	<span class="hljs-section">location</span> /&#123;<br>		<span class="hljs-attribute">proxy_pass</span> http://backend;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="缓存集成"><a href="#缓存集成" class="headerlink" title="缓存集成"></a>缓存集成</h1><ul>
<li><p>Nginx 作为 Web 缓存服务器，它介于客户端和应用服务器之间，当用户通过浏览器访问一个 URL 时，Web 缓存服务器会去应用服务器获取要展示给用户的内容，将内容缓存到自己的服务器上，当下一次请求到来时，如果访问的是同一个 URL，Web 缓存服务器就会直接将之前缓存的内容返回给客户端，而不是向应用服务器再次发送请求。Web 缓存降低了应用服务器、数据库的负载，减少了网络延迟，提高了用户访问的响应速度，增强了用户的体验。</p>
</li>
<li><p>Nginx 是从 0.7.48 版开始提供缓存功能。Nginx 是基于 Proxy Store 来实现的，<strong>其原理是把 URL 及相关组合当做 Key，在使用 MD5 算法对 Key 进行哈希化，得到硬盘上对应的哈希目录路径，从而将缓存内容保存在该目录中</strong>。它可以支持任意 URL 连接，同时也支持 404&#x2F;301&#x2F;302 这样的非200 状态码。Nginx 即可以支持对指定 URL 或者状态码设置过期时间，也可以使用 purge 命令来手动清除指定 URL 的缓存。</p>
</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/xustudyxu/image-hosting1@master/20220805/image.5rf186zoffg0.webp" alt="image"></p>
<ul>
<li>Nginx 的 Web 缓存服务主要是使用 <code>ngx_http_proxy_module</code> 模块相关指令集来完成</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lw-maple.github.io">Lost丶逝水如风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lw-maple.github.io/2022/10/19/2022-10-19-%E3%80%90Nginx%E3%80%91/">https://lw-maple.github.io/2022/10/19/2022-10-19-【Nginx】/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lw-maple.github.io" target="_blank">漫漫长夜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Nginx/">Nginx</a></div><div class="post_share"><div class="social-share" data-image="/img/coverImg/15.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/19/2022-11-20-%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91/"><img class="prev-cover" src="/img/coverImg/0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/16/2022-10-16-%E3%80%90%E5%89%91%E6%8C%87Offer(%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84)%E3%80%91/"><img class="next-cover" src="/img/coverImg/19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">剑指Offer【二叉树中和为某一值的路径】</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Nginx%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">Nginx介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">Nginx是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">Nginx的优点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%9D%97"><span class="toc-number">3.1.</span> <span class="toc-text">全局块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#events%E5%9D%97"><span class="toc-number">3.2.</span> <span class="toc-text">events块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%9D%97"><span class="toc-number">3.3.</span> <span class="toc-text">http块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2%E4%B8%8E%E8%AE%BF%E9%97%AE"><span class="toc-number">4.</span> <span class="toc-text">静态资源部署与访问</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#proxy-set-header"><span class="toc-number">4.1.</span> <span class="toc-text">proxy_set_header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proxy-redirect"><span class="toc-number">4.2.</span> <span class="toc-text">proxy_redirect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">4.3.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9D%87%E8%A1%A1%E8%B4%9F%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">均衡负载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.1.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">5.2.</span> <span class="toc-text">状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%87%E8%A1%A1%E8%B4%9F%E8%BD%BD%E7%AD%96%E7%95%A5"><span class="toc-number">5.3.</span> <span class="toc-text">均衡负载策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%86%E6%88%90"><span class="toc-number">6.</span> <span class="toc-text">缓存集成</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Lost丶逝水如风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
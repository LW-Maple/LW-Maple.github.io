<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySql高级 | 漫漫长夜</title><meta name="keywords" content="MySQL"><meta name="author" content="Lost丶逝水如风"><meta name="copyright" content="Lost丶逝水如风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="索引索引概述索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法 。  优点 （1）类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本 ，这也是创建索引最主要的原因。 （2）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。  （3）在实现数据的 参">
<meta property="og:type" content="article">
<meta property="og:title" content="MySql高级">
<meta property="og:url" content="https://lw-maple.github.io/2022/07/20/2022-7-20-%E3%80%90MySql%E9%AB%98%E7%BA%A7%E3%80%91/index.html">
<meta property="og:site_name" content="漫漫长夜">
<meta property="og:description" content="索引索引概述索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法 。  优点 （1）类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本 ，这也是创建索引最主要的原因。 （2）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。  （3）在实现数据的 参">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lw-maple.github.io/img/coverImg/12.jpg">
<meta property="article:published_time" content="2022-07-20T09:00:32.000Z">
<meta property="article:modified_time" content="2022-08-08T03:11:28.383Z">
<meta property="article:author" content="Lost丶逝水如风">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lw-maple.github.io/img/coverImg/12.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lw-maple.github.io/2022/07/20/2022-7-20-%E3%80%90MySql%E9%AB%98%E7%BA%A7%E3%80%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/img/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySql高级',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-08 11:11:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/self/atom-one-dark.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GJ411x7h7"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/coverImg/12.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">漫漫长夜</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GJ411x7h7"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySql高级</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-20T09:00:32.000Z" title="发表于 2022-07-20 17:00:32">2022-07-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-08T03:11:28.383Z" title="更新于 2022-08-08 11:11:28">2022-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySql高级"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p>索引的本质：索引是数据结构。你可以简单理解为“<strong>排好序的快速查找数据结构</strong>”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法 。</p>
<ul>
<li>优点<ul>
<li>（1）类似大学图书馆建书目索引，<strong>提高数据检索的效率，降低数据库的IO成本 ，这也是创建索引最主要的原因。</strong></li>
<li>（2）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。 </li>
<li>（3）在实现数据的 参考完整性方面，可以加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。 </li>
<li>（4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时 间 ，降低了CPU的消耗。</li>
</ul>
</li>
<li>缺点<ul>
<li>（1）<strong>创建索引和维护索引要耗费时间</strong> ，并且随着数据量的增加，所耗费的时间也会增加。 </li>
<li>（2）<strong>索引需要占磁盘空间</strong> ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。 </li>
<li>（3）虽然索引大大提高了查询速度，同时却会降低更新表的速度 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 </li>
<li>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</li>
</ul>
</li>
</ul>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。 </p>
<ul>
<li>从功能逻辑上说，索引主要有 4 种，分别是<strong>普通索引、唯一索引、主键索引、全文索引</strong>。 </li>
<li>按照 物理实现方式 ，索引可以分为 2 种：<strong>聚簇索引和非聚簇索引</strong>。 </li>
<li>按照 作用字段个数 进行划分，分成<strong>单列索引和联合索引</strong>。</li>
</ul>
<p><strong>1.普通索引</strong></p>
<ul>
<li>这是最基本的索引，它没有任何限制。</li>
</ul>
<p><strong>2.唯一索引</strong></p>
<ul>
<li>与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须一。</li>
</ul>
<p><strong>3.主键索引</strong></p>
<ul>
<li>它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候指定了主键，就会创建主键索引</li>
</ul>
<p><strong>4.全文索引</strong></p>
<ul>
<li>是MySQL专门提供用作搜索引擎的，查询数据量较大的字符串时可以提高效率</li>
</ul>
<p><strong>5.单列索引</strong></p>
<ul>
<li>在单个字段上创建的索引</li>
</ul>
<p><strong>6.多列(组合，联合)索引</strong></p>
<ul>
<li>在多个字段组合上建立的索引</li>
</ul>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="1-创建表的时候创建索引"><a href="#1-创建表的时候创建索引" class="headerlink" title="1. 创建表的时候创建索引"></a>1. 创建表的时候创建索引</h3><ul>
<li>隐式创建，规定约束时会自动创建      <strong>主键，唯一，外键</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept(<br>dept_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>dept_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp(<br>emp_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>emp_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">UNIQUE</span>,<br>dept_id <span class="hljs-type">INT</span>,<br><span class="hljs-keyword">CONSTRAINT</span> emp_dept_id_fk <span class="hljs-keyword">FOREIGN</span> KEY(dept_id) <span class="hljs-keyword">REFERENCES</span> dept(dept_id)<br>);<br></code></pre></td></tr></table></figure>

<p>但是，如果显式创建表时创建索引的话，基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name [col_name data_type]<br>[<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] [INDEX <span class="hljs-operator">|</span> KEY] [index_name] (col_name [length]) [<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<ul>
<li>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引； </li>
<li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引； </li>
<li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； </li>
<li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； </li>
<li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； </li>
<li>ASC 或 DESC 指定升序或者降序的索引值存储。</li>
</ul>
<h3 id="2-创建表之后创建"><a href="#2-创建表之后创建" class="headerlink" title="2.创建表之后创建"></a>2.创建表之后创建</h3><ul>
<li><strong>使用ALTER TABLE语句创建索引</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] [INDEX <span class="hljs-operator">|</span> KEY]<br>[index_name] (col_name[length],...) [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>使用CREATE INDEX创建索引</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT <span class="hljs-operator">|</span> SPATIAL] INDEX index_name<br><span class="hljs-keyword">ON</span> table_name (col_name[length],...) [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>

<h3 id="3-删除索引"><a href="#3-删除索引" class="headerlink" title="3.删除索引"></a>3.删除索引</h3><ul>
<li>使用ALTER TABLE删除索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> INDEX index_name;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用DROP INDEX语句删除索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>提示 </p>
<p>添加AUTO_INCREMENT约束字段的唯一索引是无法删除的</p>
<p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成 索引的所有列都被删除，则整个索引将被删除。</p>
</blockquote>
<h2 id="MySQL8-0索引新特性"><a href="#MySQL8-0索引新特性" class="headerlink" title="MySQL8.0索引新特性"></a>MySQL8.0索引新特性</h2><h3 id="支持降序索引"><a href="#支持降序索引" class="headerlink" title="支持降序索引"></a>支持降序索引</h3><ul>
<li>降序索引以降序存储键值。虽然在语法上，从MysQL 4版本开始就已经支持降序索引的语法了，但实际上该DESC定义是被忽略的，直到MysQL 8.x版本才开始真正支持降序索引(仅限于InnoDB存储引擎)。</li>
<li><strong>MysQL在8.o版本之前创建的仍然是升序索引，使用时进行反向扫描</strong>，这大大降低了数据库的效率在某些场景下，降序索引意义重大。</li>
<li>例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</li>
</ul>
<h3 id="支持隐藏索引"><a href="#支持隐藏索引" class="headerlink" title="支持隐藏索引"></a>支持隐藏索引</h3><ul>
<li>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能 通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。 </li>
<li>从MySQL 8.x开始支持 隐藏索引（invisible indexes） ，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引）， 确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 </li>
<li><strong>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除</strong> 。</li>
</ul>
<h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h2><h3 id="适合创建索引的11种情况"><a href="#适合创建索引的11种情况" class="headerlink" title="适合创建索引的11种情况"></a>适合创建索引的11种情况</h3><p><strong>1.字段的数值有唯一性的限制</strong></p>
<blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba） </p>
<p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
</blockquote>
<p><strong>2.频繁作为 WHERE 查询条件的字段</strong></p>
<ul>
<li>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。</li>
<li>尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。 比如student_info数据表（含100万条数据），假设我们想要查询 student_id&#x3D;123110 的用户信息。</li>
</ul>
<p><strong>3.经常 GROUP BY 和 ORDER BY 的列</strong></p>
<ul>
<li>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引 。</li>
<li>如果待排序的列有多 个，那么可以在这些列上建立组合索引 。</li>
</ul>
<p><strong>4.UPDATE、DELETE 的 WHERE 条件列</strong></p>
<ul>
<li>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。</li>
<li>原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或 删除。</li>
<li><strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></li>
</ul>
<p><strong>5.DISTINCT 字段需要创建索引</strong></p>
<ul>
<li>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</li>
</ul>
<p><strong>6.多表 JOIN 连接操作时，创建索引注意事项</strong></p>
<ul>
<li>首先， 连接表的数量尽量不要超过 3 张 ，<strong>因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</strong> </li>
<li>其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下， 没有 WHERE 条件过滤是非常可怕的。 </li>
<li>最后， 对用于连接的字段创建索引 ，并且<strong>该字段在多张表中的类型必须一致</strong> 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型(索引会失效)。</li>
</ul>
<p><strong>7.使用列的类型小的创建索引</strong></p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I&#x2F;0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul>
<p><strong>8.使用字符串前缀创建索引</strong></p>
<p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题:</p>
<ul>
<li>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。</li>
<li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li>
<li>我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。</li>
</ul>
<p><strong>9.区分度高(散列性高)的列适合作为索引</strong></p>
<p><strong>10使用最频繁的列放到联合索引的左侧</strong> </p>
<p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。</p>
<p><strong>11.在多个字段都要创建索引的情况下，联合索引优于单值索引</strong></p>
<p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过6个。原因:</p>
<ul>
<li>每个索引都需要占用磁盘空间，<strong>索引越多，需要的磁盘空间就越大</strong>。</li>
<li>索引会影响INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，<strong>索引也会进行调整和更新，会造成负担</strong>。</li>
<li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</li>
</ul>
<h3 id="哪些情况不适合创建索引"><a href="#哪些情况不适合创建索引" class="headerlink" title="哪些情况不适合创建索引"></a>哪些情况不适合创建索引</h3><ul>
<li><p>在where中使用不到的字段，不要设置索引</p>
</li>
<li><p>数据量小的表最好不要使用索引</p>
</li>
</ul>
<blockquote>
<p>结论：在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。</p>
</blockquote>
<ul>
<li>有大量重复数据的列上不要建立索引</li>
</ul>
<p>举例：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先 访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p>
<ul>
<li>避免对经常更新的表创建过多的索引</li>
<li>不建议用无序的值作为索引</li>
</ul>
<p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。</p>
<ul>
<li><p>删除不再使用或者很少使用的索引</p>
</li>
<li><p>不要定义冗余或重复的索引</p>
</li>
</ul>
<h3 id="索引使用注意事项"><a href="#索引使用注意事项" class="headerlink" title="索引使用注意事项"></a>索引使用注意事项</h3><p><strong>全值匹配我最爱</strong></p>
<ul>
<li>建立几个复合索引字段，最好就用上几个字段。且按照顺序来用。</li>
</ul>
<p><strong>最佳左前缀法则</strong></p>
<ul>
<li>建立联合索引时，必须按照严格的顺序。</li>
<li>要使用联合索引的话，必须先从左边考虑(必须包含左边的字段，才可以使用后面的字段)。一旦跳过某个字段，则后面的字段都没办法使用，但是前面的字段可以使用索引</li>
</ul>
<p><strong>主键插入顺序</strong></p>
<ul>
<li><p>对于一个使用InnoDB存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，<strong>所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，就比较麻烦了会造成页分裂，第一页的一些记录会移动到第二页</strong></p>
</li>
<li><p>页面分裂和记录移位意味着什么?意味着:性能损耗!</p>
</li>
<li><p>所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议:让主键具有AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入</p>
</li>
</ul>
<h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><p><strong>计算，函数，类型转化(自动或者手动)导致造成索引失效</strong></p>
<p><strong>范围条件右边的列索引失效</strong></p>
<ul>
<li>所以，建立联合字段索引时，需要把范围索引字段放在最后面，不然范围索引后面的字段则使用不到 (当然，你只更换查询语句里的顺序，肯定是不能改变效果的,优化器都会帮你修改，而索引是不会改变的)</li>
</ul>
<p><strong>&lt;&gt;和!&#x3D;不等于索引失效</strong></p>
<ul>
<li>因为在B+树中查找不等于时，只能一个个去查找，导致索引失效</li>
</ul>
<p><strong>is null可以使用索引，is not null不能使用索引</strong></p>
<ul>
<li><p>因为is null相当于是等值，is not null相当于是不等于</p>
</li>
<li><p>最好在设计数据表的时候就将字段设置为 NOT NULL约束，比如你可以将INT类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串()。<br>拓展:同理，在查询中使用<code>not like</code> 也无法使用索引，导致全表扫描。</p>
</li>
</ul>
<p><strong>like以通配符%开头索引失效</strong></p>
<p><strong>OR前后存在非索引的列，索引失效</strong></p>
<ul>
<li>因为or的话，相当于你两边都要；如果你走索引的话，相当于要先走一遍索引字段，然后再全表走没有索引的字段，这样还不如全表来的更快。</li>
</ul>
<p><strong>数据库和表的字符集同一使用utf8mb4</strong></p>
<ul>
<li>不同字符集会导致转换产生乱码，不同的字符集进行比较前会进行转换，造成索引失效</li>
</ul>
<h2 id="外连接内连接的优化"><a href="#外连接内连接的优化" class="headerlink" title="外连接内连接的优化"></a>外连接内连接的优化</h2><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><ul>
<li>如果只能使用一个索引，对被驱动表使用索引，因为连接查询实际上是遍历两个表进行查询，被驱动表通过驱动表查询的条件进行查询，此时被驱动表就可以用上索引</li>
</ul>
<h3 id="内连接-小表驱动大表"><a href="#内连接-小表驱动大表" class="headerlink" title="内连接(小表驱动大表)"></a>内连接(小表驱动大表)</h3><ul>
<li>对于内连接来说，优化器可以选择驱动表和被驱动表<ul>
<li>只有一个索引的情况下，优先将有索引的表作为被驱动表</li>
<li>当有两个 索引的条件下，优化器会做出抉择，数据量小的作为驱动表（因为此表要进行全遍历）</li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>保证被驱动表的JOIN字段已经创建了索引 </li>
<li>需要JOIN 的字段，数据类型保持绝对一致。 </li>
<li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。 </li>
<li>INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。 </li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数) </li>
<li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。 </li>
<li>衍生表建不了索引</li>
</ul>
<h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h2><ul>
<li>MySQL从4.1版本开始支持子查询，<strong>使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结果作为另一个SELECT语句的条件。</strong> 子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作 。 子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。</li>
<li>但是，子查询的执行效率不高。原因：<ul>
<li>① 执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表 中查询记录。查询完毕后，再撤销这些临时表 。这样会消耗过多的CPU和IO资源，<strong>产生大量的慢查询</strong>。</li>
<li>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引 ，所以查询性能会受到一定的影响。</li>
<li>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大</li>
</ul>
</li>
<li>在MySQL中，<strong>可以使用连接（JOIN）查询来替代子查询。</strong>连接查询不需要建立临时表 ，其速度比子查询要快 ，如果查询中使用索引的话，性能就会更好。</li>
</ul>
<blockquote>
<p><strong>结论：尽量不要使用NOT IN 或者 NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</strong></p>
</blockquote>
<h2 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h2><p>在MySQL 中，支持两种排序方式，分别是FileSort和Index排序。</p>
<ul>
<li><strong>Index</strong>排序中，索引可以保证数据的有序性，不需要再进行排序，<strong>效率更高</strong>。</li>
<li><strong>FileSort</strong>排序则一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I&#x2F;o到磁盘进行排序的情况，<strong>效率较低</strong>。</li>
</ul>
<p>优化建议： </p>
<ul>
<li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，<ul>
<li>目的是在 WHERE 子句中避免全表扫描 。</li>
<li>在 ORDER BY 子句 避免使用 FileSort 排序 。</li>
<li>当然，某些情况下全表扫描，或者 FileSort 排 序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li>
</ul>
</li>
<li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。 </li>
<li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li>
</ul>
<h2 id="Group-by优化"><a href="#Group-by优化" class="headerlink" title="Group by优化"></a>Group by优化</h2><ul>
<li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。 </li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀法则 </li>
<li>当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置 </li>
<li>where效率高于having，能写在where限定的条件就不要写在having中了 </li>
<li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。 </li>
<li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。</li>
</ul>
<h2 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h2><p>优化思路一： 在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student t,(<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id LIMIT <span class="hljs-number">2000000</span>,<span class="hljs-number">10</span>)<br>a<br><span class="hljs-keyword">WHERE</span> t.id <span class="hljs-operator">=</span> a.id;<br></code></pre></td></tr></table></figure>

<p>优化思路二： 该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">2000000</span> LIMIT <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><ul>
<li><p>一个索引包含了满足查询结果的数据就叫做覆盖索引(不需要回表操作)。</p>
</li>
<li><p>简单说就是， 索引列+主键 包含 SELECT 到 FROM之间查询的列 。</p>
</li>
</ul>
<p>覆盖索引的利弊 </p>
<ul>
<li>好处：避免Innodb表进行索引的二次查询（回表） 2. 可以把随机IO变成顺序IO加快查询效率 </li>
<li>弊端： 索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</li>
</ul>
<h2 id="淘宝数据库，主键如何设计的？"><a href="#淘宝数据库，主键如何设计的？" class="headerlink" title="淘宝数据库，主键如何设计的？"></a>淘宝数据库，主键如何设计的？</h2><h3 id="自增ID的问题"><a href="#自增ID的问题" class="headerlink" title="自增ID的问题"></a>自增ID的问题</h3><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除 了简单，其他都是缺点，总体来看存在以下几方面的问题： </p>
<p><strong>可靠性不高</strong> </p>
<p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。</p>
<p><strong>安全性不高</strong></p>
<p>对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;User&#x2F;1&#x2F;这样的接口，可以非常容易猜测用户ID的 值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</p>
<p><strong>性能差</strong></p>
<p>自增ID的性能较差，需要在数据库服务器端生成。</p>
<p><strong>交互多</strong></p>
<p>业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的 网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</p>
<p><strong>局部唯一性</strong></p>
<p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都 是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p>
<h3 id="不要选择业务字段做主键"><a href="#不要选择业务字段做主键" class="headerlink" title="不要选择业务字段做主键"></a>不要选择业务字段做主键</h3><p>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测 在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。</p>
<blockquote>
<p>经验： 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业 务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p>
</blockquote>
<h3 id="推荐的主键设计"><a href="#推荐的主键设计" class="headerlink" title="推荐的主键设计"></a>推荐的主键设计</h3><p>非核心业务 ：对应表的主键自增ID，如告警、日志、监控等信息。 </p>
<p>核心业务 ：<strong>主键设计至少应该是全局唯一且是单调递增</strong>。全局唯一保证在各系统之间都是唯一的，单调 递增是希望插入时不影响数据库性能。 这里推荐最简单的一种主键设计：UUID。</p>
<ul>
<li><strong>UUID的特点</strong>： 全局唯一，占用36字节，数据无序，插入性能差。</li>
<li>MYSQL中UUID组成为<code>UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）</code></li>
</ul>
<p><img src="https://s1.ax1x.com/2022/07/19/jTHHKA.png"></p>
<p><strong>为什么UUID是全局唯一的？</strong> </p>
<ul>
<li>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00 到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降 低到1&#x2F;100ns。 时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</li>
</ul>
<p><strong>为什么UUID占用36个字节？</strong></p>
<ul>
<li>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。</li>
</ul>
<p><strong>为什么UUID是随机无序的呢？</strong> </p>
<ul>
<li>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</li>
</ul>
<p><strong>改善UUID</strong></p>
<ul>
<li>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。</li>
<li>MySQL 8.0可以更换时间低位和 时间高位的存储方式，这样UUID就是有序的UUID了。 </li>
<li>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节 。</li>
</ul>
<h2 id="数据库设计规范"><a href="#数据库设计规范" class="headerlink" title="数据库设计规范"></a>数据库设计规范</h2><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式</strong>。可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别 要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><ul>
<li>1NF（第一范式）是指数据库表的每一列都是<strong>不可分割</strong>的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。</li>
<li>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</li>
</ul>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><ul>
<li>第二范式要求，在满足第一范式的基础上，还要满足<strong>数据表里的每一条数据记录，都是可唯一标识的</strong>。</li>
<li><strong>而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。</strong></li>
<li>如果知道主键的所有属性的值，就可以检索到任何元组(行)的任何属性的任何值。(要求中的主键，其实可以拓展替换为候选键)。|</li>
</ul>
<p><strong>对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？</strong></p>
<p>假设有球员表：<code>(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</code></p>
<ul>
<li><strong>数据冗余</strong> ：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛 也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。</li>
<li><strong>插入异常</strong> ：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没 法插入。</li>
<li><strong>删除异常</strong> ：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删 除掉。 </li>
<li><strong>更新异常</strong> ：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调 整，否则就会出现一场比赛时间不同的情况。</li>
</ul>
<p>为了避免出现上述的情况，我们可以把球员比赛表设计为下面的三张表。</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>球员表</td>
<td>球员编号，姓名，年龄</td>
</tr>
<tr>
<td>比赛表</td>
<td>比赛编号，比赛时间，比赛场地</td>
</tr>
<tr>
<td>球员比赛关系表</td>
<td>球员编号，比赛编号，得分等属性</td>
</tr>
</tbody></table>
<p>这样的话，每张数据表都符合第二范式，也就避免了异常情况的发生。</p>
<blockquote>
<p>1NF 告诉我们字段属性需要是原子性的，</p>
<p>2NF 告诉我们一张表就是一个独立的对象，一张表只表达一个意思。</p>
<p>小结:第二范式(2NF)要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是<strong>一对多</strong>的关系。</p>
</blockquote>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段</strong>。(即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键c的情况，即存在”A一B→C””的决定关系）通俗地讲，<strong>该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。</strong></p>
<blockquote>
<p>符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非主键属性依赖于主键，依赖于整个主键，并且除了键别无他物”。</p>
</blockquote>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>关于数据表的设计，有三个范式要遵循。</p>
<p>(1）第一范式(1NF)，确保每列保持<strong>原子性</strong></p>
<ul>
<li>数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项</li>
</ul>
<p>(2)第二范式（2NF)，确保每列都和主键<strong>完全依赖</strong></p>
<ul>
<li>尤其在复合主键的情况下，非主键部分不应该依赖于部分主键。</li>
</ul>
<p>(3）第三范式(3NF）确保每列都和主键列<strong>直接相关</strong>，而不是间接相关</p>
<p>**范式的优点:**数据的标准化有助于消除数据库中的数据冗余，第三范式(3NF）通常被认为在性能、扩展性和数据完整性方面达到了最好的平衡。</p>
<p>**范式的缺点:**范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。范式只是提出了设计的标准，实际上设计数据时，未必一定要符合这些标准。</p>
<blockquote>
<p>开发中，我们会出现为了性能和读取效率违反范式化的原则，通过增加少量的冗余或重复的数据来提高据库的读性能，减少关联查询，join表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p>
</blockquote>
<h3 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h3><ul>
<li>有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循业务优先的原则，首先满足业务需求，再尽量减少冗余。</li>
<li>如果数据库中的数据量比较大，系统的UV和PV访问频次比较高，则完全按照MysQL的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，反范式优化也是一种优化思路。此时，可以通过在数据表中增加冗余字段来提高数据库的读性能。</li>
</ul>
<ol>
<li>为满足某种商业目标 , 数据库性能比规范化数据库更重要</li>
<li>在数据规范化的同时 , 要综合考虑数据库的性能 </li>
<li>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</li>
<li>通过在给定的表中插入计算列，以方便查询</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lw-maple.github.io">Lost丶逝水如风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lw-maple.github.io/2022/07/20/2022-7-20-%E3%80%90MySql%E9%AB%98%E7%BA%A7%E3%80%91/">https://lw-maple.github.io/2022/07/20/2022-7-20-【MySql高级】/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lw-maple.github.io" target="_blank">漫漫长夜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="/img/coverImg/12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/23/2022-7-23-%E3%80%90LeetCode%E7%99%BE%E9%A2%98(%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84)%E3%80%91/"><img class="prev-cover" src="/img/coverImg/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LeetCode百题【和为 K 的子数组】</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/20/2022-7-20-%E3%80%90LeetCode%E7%99%BE%E9%A2%98(%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6)%E3%80%91/"><img class="next-cover" src="/img/coverImg/21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LeetCode百题【每日温度】</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/24/2022-1-24-%E3%80%90MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E3%80%91/" title="MySQL数据库学习"><img class="cover" src="/img/coverImg/0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-24</div><div class="title">MySQL数据库学习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">索引概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">索引的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">2.</span> <span class="toc-text">创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.</span> <span class="toc-text">1. 创建表的时候创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E8%A1%A8%E4%B9%8B%E5%90%8E%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">2.创建表之后创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.</span> <span class="toc-text">3.删除索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL8-0%E7%B4%A2%E5%BC%95%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">MySQL8.0索引新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">3.1.</span> <span class="toc-text">支持降序索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.</span> <span class="toc-text">支持隐藏索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.</span> <span class="toc-text">索引的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%8411%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">4.1.</span> <span class="toc-text">适合创建索引的11种情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">4.2.</span> <span class="toc-text">哪些情况不适合创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.3.</span> <span class="toc-text">索引使用注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">4.4.</span> <span class="toc-text">索引失效的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5%E5%86%85%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">外连接内连接的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.1.</span> <span class="toc-text">外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5-%E5%B0%8F%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%A4%A7%E8%A1%A8"><span class="toc-number">5.2.</span> <span class="toc-text">内连接(小表驱动大表)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">子查询优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">排序优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Group-by%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">Group by优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">9.</span> <span class="toc-text">优化分页查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">10.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%98%E5%AE%9D%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">淘宝数据库，主键如何设计的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9EID%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">11.1.</span> <span class="toc-text">自增ID的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E9%80%89%E6%8B%A9%E4%B8%9A%E5%8A%A1%E5%AD%97%E6%AE%B5%E5%81%9A%E4%B8%BB%E9%94%AE"><span class="toc-number">11.2.</span> <span class="toc-text">不要选择业务字段做主键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">11.3.</span> <span class="toc-text">推荐的主键设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">12.</span> <span class="toc-text">数据库设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F"><span class="toc-number">12.1.</span> <span class="toc-text">范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F"><span class="toc-number">12.1.1.</span> <span class="toc-text">第一范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F"><span class="toc-number">12.1.2.</span> <span class="toc-text">第二范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">12.1.3.</span> <span class="toc-text">第三范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">12.1.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%8C%83%E5%BC%8F"><span class="toc-number">12.2.</span> <span class="toc-text">反范式</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Lost丶逝水如风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
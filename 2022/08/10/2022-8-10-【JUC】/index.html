<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java并发编程 | 漫漫长夜</title><meta name="keywords" content="JUC"><meta name="author" content="Lost丶逝水如风"><meta name="copyright" content="Lost丶逝水如风"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="相关概念进程：程序是静止的，进程实体的运行过程就是进程，是系统进行资源分配的基本单位 进程的特征：并发性、异步性、动态性、独立性、结构性 线程：线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统独立调度的基本单位，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源 关系：一个进程可以包含多">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="https://lw-maple.github.io/2022/08/10/2022-8-10-%E3%80%90JUC%E3%80%91/index.html">
<meta property="og:site_name" content="漫漫长夜">
<meta property="og:description" content="相关概念进程：程序是静止的，进程实体的运行过程就是进程，是系统进行资源分配的基本单位 进程的特征：并发性、异步性、动态性、独立性、结构性 线程：线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统独立调度的基本单位，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源 关系：一个进程可以包含多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lw-maple.github.io/img/coverImg/10.jpg">
<meta property="article:published_time" content="2022-08-10T09:33:38.000Z">
<meta property="article:modified_time" content="2022-08-10T09:33:50.504Z">
<meta property="article:author" content="Lost丶逝水如风">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lw-maple.github.io/img/coverImg/10.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lw-maple.github.io/2022/08/10/2022-8-10-%E3%80%90JUC%E3%80%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/img/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/img/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/pwa/16.png"/><link rel="mask-icon" href="/img/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-10 17:33:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/self/atom-one-dark.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">98</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GJ411x7h7"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/coverImg/10.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">漫漫长夜</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GJ411x7h7"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-10T09:33:38.000Z" title="发表于 2022-08-10 17:33:38">2022-08-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-10T09:33:50.504Z" title="更新于 2022-08-10 17:33:50">2022-08-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE%E9%AB%98%E7%BA%A7/">JavaSE高级</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>54分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>进程：程序是静止的，进程实体的运行过程就是进程，是系统进行<strong>资源分配的基本单位</strong></p>
<p>进程的特征：并发性、异步性、动态性、独立性、结构性</p>
<p><strong>线程</strong>：线程是属于进程的，是一个基本的 CPU 执行单元，是程序执行流的最小单元。线程是进程中的一个实体，是系统<strong>独立调度的基本单位</strong>，线程本身不拥有系统资源，只拥有一点在运行中必不可少的资源，与同属一个进程的其他线程共享进程所拥有的全部资源</p>
<p>关系：一个进程可以包含多个线程，这就是多线程，比如看视频是进程，图画、声音、广告等就是多个线程</p>
<p>线程的作用：使多道程序更好的并发执行，提高资源利用率和系统吞吐量，增强操作系统的并发性能</p>
<p>并发并行：</p>
<ul>
<li>并行：在同一时刻，有多个指令在多个 CPU 上同时执行</li>
<li>并发：在同一时刻，有多个指令在单个 CPU 上交替执行</li>
</ul>
<p>同步异步：</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<p><strong>线程进程对比：</strong></p>
<ul>
<li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p>
</li>
<li><p>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong></p>
</li>
<li><p>进程间通信较为复杂</p>
<p>同一台计算机的进程通信称为 IPC（Inter-process communication）</p>
<ul>
<li><p>信号量：信号量是一个计数器，用于多进程对共享数据的访问，解决同步相关的问题并避免竞争条件</p>
</li>
<li><p>共享存储：多个进程可以访问同一块内存空间，需要使用信号量用来同步对共享存储的访问</p>
</li>
<li><p>管道通信：管道是用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 pipe 文件，该文件同一时间只允许一个进程访问，所以只支持</p>
<p>半双工通信</p>
<ul>
<li>匿名管道（Pipes）：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信</li>
<li>命名管道（Names Pipes）：以磁盘文件的方式存在，可以实现本机任意两个进程通信，遵循 FIFO</li>
</ul>
</li>
<li><p>消息队列：内核中存储消息的链表，由消息队列标识符标识，能在不同进程之间提供</p>
<p>全双工通信</p>
<p>，对比管道：</p>
<ul>
<li>匿名管道存在于内存中的文件；命名管道存在于实际的磁盘介质或者文件系统；消息队列存放在内核中，只有在内核重启（操作系统重启）或者显示地删除一个消息队列时，该消息队列才被真正删除</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li>
</ul>
</li>
</ul>
<p>不同计算机之间的<strong>进程通信</strong>，需要通过网络，并遵守共同的协议，例如 HTTP</p>
<ul>
<li>套接字：与其它通信机制不同的是，可用于不同机器间的互相通信</li>
</ul>
</li>
<li><p>线程通信相对简单，因为线程之间共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p>
<p><strong>Java 中的通信机制</strong>：volatile、等待&#x2F;通知机制、join 方式、InheritableThreadLocal、MappedByteBuffer</p>
</li>
<li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p>
</li>
</ul>
<hr>
<h3 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h3><h4 id="实现多线程的方式"><a href="#实现多线程的方式" class="headerlink" title="实现多线程的方式"></a>实现多线程的方式</h4><h5 id="1-继承Thread类，重写该类的run-方法"><a href="#1-继承Thread类，重写该类的run-方法" class="headerlink" title="1.继承Thread类，重写该类的run()方法"></a>1.继承Thread类，重写该类的run()方法</h5><p>Thread 构造器：</p>
<ul>
<li><code>public Thread()</code></li>
<li><code>public Thread(String name)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t.start();<br>       	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ )&#123;<br>            System.out.println(<span class="hljs-string">&quot;main线程&quot;</span> + i)<br>        &#125;<br>        <span class="hljs-comment">// main线程输出放在上面 就变成有先后顺序了，因为是 main 线程驱动的子线程运行</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ; i++ ) &#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程输出：&quot;</span>+i)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-实现Runnable接口，并重写该接口的run-方法"><a href="#2-实现Runnable接口，并重写该接口的run-方法" class="headerlink" title="2.实现Runnable接口，并重写该接口的run()方法"></a>2.实现Runnable接口，并重写该接口的run()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target,<span class="hljs-string">&quot;1号线程&quot;</span>);<br>		t1.start();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target);<span class="hljs-comment">//Thread-0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++ )&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;-&gt;&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-实现-Callable-接口：接口创建线程。"><a href="#3-实现-Callable-接口：接口创建线程。" class="headerlink" title="3.实现 Callable 接口：接口创建线程。"></a>3.实现 Callable 接口：接口创建线程。</h5><ol>
<li>定义一个线程任务类实现 Callable 接口，申明线程执行的结果类型</li>
<li>重写线程任务类的 call 方法，这个方法可以直接返回执行的结果</li>
<li>创建一个 Callable 的线程任务对象</li>
<li>把 Callable 的线程任务对象<strong>包装成一个未来任务对象</strong></li>
<li>把未来任务对象包装成线程对象</li>
<li>调用线程的 start() 方法启动线程</li>
</ol>
<p><code>public FutureTask(Callable&lt;V&gt; callable)</code>：未来任务对象，在线程执行完后得到线程的执行结果</p>
<ul>
<li>FutureTask 就是 Runnable 对象，因为 <strong>Thread 类只能执行 Runnable 实例的任务对象</strong>，所以把 Callable 包装成未来任务对象</li>
<li>线程池部分详解了 FutureTask 的源码</li>
</ul>
<p><code>public V get()</code>：同步等待 task 执行完毕的结果，如果在线程中获取另一个线程执行结果，会阻塞等待，用于线程同步</p>
<ul>
<li>get() 线程会阻塞等待任务执行完成</li>
<li>run() 执行完后会把结果设置到 FutureTask 的一个成员变量，get() 线程可以获取到该变量的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br> <br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> count; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-comment">//			Thread.yield();</span><br>			System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;当前票数：&quot;</span> + i);<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sale out&quot;</span>;<br>	&#125; <br> <br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>		Callable&lt;String&gt; callable  =<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>		FutureTask &lt;String&gt;futureTask=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br>		Thread mThread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>		Thread mThread2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>		Thread mThread3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br><span class="hljs-comment">//		mThread.setName(&quot;hhh&quot;);</span><br>		mThread.start();<br>		mThread2.start();<br>		mThread3.start();<br>		System.out.println(futureTask.get());<br>		<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="4-通过线程池启动多线程"><a href="#4-通过线程池启动多线程" class="headerlink" title="4.通过线程池启动多线程"></a>4.通过线程池启动多线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		ExecutorService ex=Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>		<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>			ex.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>				<br>				<span class="hljs-meta">@Override</span><br>				<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>					<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>;j++) &#123;<br>						System.out.println(Thread.currentThread().getName()+j);<br>					&#125;<br>					<br>				&#125;<br>			&#125;);<br>		&#125;<br>		ex.shutdown();<br>	&#125;	<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><strong>start和run</strong></p>
<ul>
<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </li>
<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>
</ul>
<p> <strong>sleep 与 yield</strong> </p>
<ul>
<li><p>sleep：</p>
<ul>
<li>调用 sleep 会让当前线程从 <em>Running</em>进入 <em>Timed Waiting</em> 状态（阻塞） </li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException </li>
<li>睡眠结束后的线程未必会立刻得到执行 </li>
<li>建议用 TimeUnit(时间单位) 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>
</ul>
</li>
<li><p>yield</p>
<ul>
<li>调用 yield 会让当前线程从 <em>Running</em> 进入 <em>Runnable</em>就绪状态，然后调度执行其它线程 </li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ul>
</li>
<li><p>线程优先级 </p>
<ul>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 </li>
<li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li>
</ul>
</li>
</ul>
<blockquote>
<p>在没有利用 cpu 来计算时，不要让 while(true) 空转浪费 cpu，这时可以使用 yield 或 sleep 来让出 cpu 的使用权 给其他程序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>join<ul>
<li>等待线程运行结束</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    test1();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;开始&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>        r = <span class="hljs-number">10</span>;<br>    &#125;);<br>    t1.start();<br>    t1.join();<br>    log.debug(<span class="hljs-string">&quot;结果为:&#123;&#125;&quot;</span>, r);<br>    log.debug(<span class="hljs-string">&quot;结束&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>需要等待结果返回，才能继续运行就是同步</p>
<p>不需要等待结果返回，就能继续运行就是异步</p>
</blockquote>
<ul>
<li><p>interrupt </p>
</li>
<li><p>打断 sleep，wait，join 的线程 </p>
<ul>
<li>这几个方法都会让线程进入阻塞状态</li>
</ul>
</li>
<li><p>打断 sleep 的线程, 会清空打断状态，以 sleep 为例</p>
<ul>
<li>打断状态:描述一个线程是否被打断的布尔值</li>
</ul>
</li>
<li><p>打断正常运行的线程不会清空打断状态</p>
</li>
<li><p><strong>两阶段终止模式</strong></p>
</li>
</ul>
<p>在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>W(&quot;while(true)&quot;) --&gt; a<br>a(&quot;有没有被打断?&quot;) --是--&gt; b(料理后事)<br>b --&gt;  c((结束循环))<br>a--否 --&gt; d(睡眠2s)<br>d --无异常--&gt; e(执行监控记录)<br>d --有异常--&gt; i(设置打断标记)<br>i--&gt;W<br>e--&gt;W<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TPTInterrupt</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                <span class="hljs-keyword">if</span>(current.isInterrupted()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;将结果保存&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    current.interrupt();<br>                &#125;<br>                <span class="hljs-comment">// 执行监控操作 </span><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;监控线程&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TPTInterrupt</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TPTInterrupt</span>();<br>t.start();<br><br>Thread.sleep(<span class="hljs-number">3500</span>);<br>log.debug(<span class="hljs-string">&quot;stop&quot;</span>);<br>t.stop();<br></code></pre></td></tr></table></figure>

<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul>
<li>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。</li>
<li>有一种特殊的线程叫做守护线程，<strong>只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">log.debug(<span class="hljs-string">&quot;开始运行...&quot;</span>);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>log.debug(<span class="hljs-string">&quot;开始运行...&quot;</span>);<br>sleep(<span class="hljs-number">2</span>);<br>log.debug(<span class="hljs-string">&quot;运行结束...&quot;</span>);<br>&#125;, <span class="hljs-string">&quot;daemon&quot;</span>);<br><span class="hljs-comment">// 设置该线程为守护线程</span><br>t1.setDaemon(<span class="hljs-literal">true</span>);<br>t1.start();<br><br>sleep(<span class="hljs-number">1</span>);<br>log.debug(<span class="hljs-string">&quot;运行结束...&quot;</span>);<br></code></pre></td></tr></table></figure>

<h4 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h4><ul>
<li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联 </p>
</li>
<li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 </p>
</li>
<li><p>【运行状态】指获取了 CPU 时间片运行中的状态 </p>
</li>
<li><ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li><p>【阻塞状态】 </p>
</li>
<li><ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】 </li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】 </li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
</ul>
</li>
<li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p>
</li>
</ul>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronized 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>，临界区内的代码对外是不可分割的，不会被线程切换所打断。 </p>
<p>加在对象上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            value++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            value--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                room.increment();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                room.decrement();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();        <br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span> , room.get());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>加在方法上：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br>等价于<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>锁住了调用这个方法的对象</li>
</ul>
<p><strong>加在静态方法上：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>&#125;<br>等价于<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(Test.class) &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>锁住了当前类</li>
</ul>
<hr>
<h3 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h3><p>管程可以看做⼀个软件模块，它是将<strong>共享的变量和对于这些共享变量的操作封装起来，形成⼀个具有⼀定接口的功能模块，进程可以调⽤管程来实现进程级别的并发控制。</strong></p>
<h4 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h4><p><strong>成员变量和静态变量是否线程安全？</strong> </p>
<ul>
<li><p>如果它们没有共享，则线程安全 </p>
</li>
<li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 </p>
</li>
<li><ul>
<li>如果只有读操作，则线程安全 </li>
<li><strong>如果有读写操作，则这段代码是临界区，需要考虑线程安全</strong></li>
</ul>
</li>
</ul>
<p><strong>局部变量是否线程安全？</strong> </p>
<ul>
<li><p>局部变量是线程安全的 </p>
</li>
<li><p>但局部变量引用的对象则未必 </p>
</li>
<li><ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的 </li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h4 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h4><ul>
<li>String </li>
<li>Integer </li>
<li>StringBuffffer </li>
<li>Random </li>
<li>Vector </li>
<li>Hashtable </li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>这里说它们是线程安全的是指，多个线程调用<strong>它们同一个实例</strong>的某个方法时，是线程安全的。</p>
<blockquote>
<p>但注意它们<strong>多个方法的组合不是原子的</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>participant t1 as 线程1<br>participant t2 as 线程2<br>participant table<br>t1 -&gt;&gt; table : get(&quot;key&quot;)==nu11<br>t2 -&gt;&gt; table : get(&quot;key&quot;)==nu1l<br>t2 -&gt;&gt; table : put(&quot;key&quot;, v2)<br>t1 -&gt;&gt; table : put(&quot;key&quot;, v1)<br></code></pre></td></tr></table></figure>

<ul>
<li>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</li>
</ul>
<h4 id="原理之-Monitor-锁"><a href="#原理之-Monitor-锁" class="headerlink" title="原理之 Monitor(锁)"></a>原理之 Monitor(锁)</h4><p><img src="https://s1.ax1x.com/2022/08/01/vAuRmT.png"></p>
<ul>
<li>刚开始 Monitor 中 Owner 为 null </li>
<li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner </li>
<li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList(阻塞队列) BLOCKED </li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的 </li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析</li>
</ul>
<blockquote>
<p>synchronized 必须是进入同一个对象的 monitor 才有上述的效果 </p>
<p>不加 synchronized 的对象不会关联监视器，不遵从以上规则</p>
<p><strong>Monitor是操作系统C++实现的</strong></p>
</blockquote>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p>
<ol>
<li>创建 锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</li>
</ol>
<p><img src="https://s1.ax1x.com/2022/08/03/vZnYAU.png"></p>
<ol start="2">
<li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>
<li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</li>
</ol>
<p><img src="https://s1.ax1x.com/2022/08/03/vZnhjI.png"></p>
<ul>
<li><p>如果 cas 失败，有两种情况 </p>
<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 </li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ul>
</li>
<li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 </p>
<ul>
<li>成功，则解锁成功 </li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h5 id="重量级锁（膨胀）"><a href="#重量级锁（膨胀）" class="headerlink" title="重量级锁（膨胀）"></a>重量级锁（膨胀）</h5><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 </p>
<ul>
<li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址<br>然后自己进入 Monitor 的 EntryList BLOCKED</li>
</ul>
<p><img src="https://s1.ax1x.com/2022/08/03/vZuD2j.png"></p>
<h5 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h5><p>重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，<strong>之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS</strong>。以后只要不发生竞争，这个对象就归该线程所有 </p>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@Warmup(iterations=3)</span><br><span class="hljs-meta">@Measurement(iterations=5)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBenchmark</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        x++;<br>    &#125;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//这里的o是局部变量,不会被共享,JIT做热点代码优化时会做锁消除</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">synchronized</span> (o) &#123;<br>            x++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结：synchronized默认是使用轻量级锁，轻量级锁发生抢占时会升级为重锁，然后阻塞队列可以通过自旋优化来尽可能减少阻塞</strong></p>
<h4 id="wait-x2F-notify"><a href="#wait-x2F-notify" class="headerlink" title="wait&#x2F;notify"></a>wait&#x2F;notify</h4><ul>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 </li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 </li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒 </li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li>
</ul>
<p><img src="https://s1.ax1x.com/2022/08/03/vZlfmR.png"></p>
<ul>
<li>obj.wait() 让进入 object 监视器的线程到 waitSet 等待 </li>
<li>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒 </li>
<li>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</li>
</ul>
<p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。<strong>必须获得此对象的锁，才能调用这几个方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>    <span class="hljs-keyword">while</span>(条件不成立) &#123;<br>        lock.wait();<br>    &#125;<br>    <span class="hljs-comment">// 干活</span><br>&#125;<br><br><span class="hljs-comment">//另一个线程</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>    lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="保护性暂停"><a href="#保护性暂停" class="headerlink" title="保护性暂停"></a>保护性暂停</h4><p><strong>(同步)模式之保护性暂停</strong></p>
<p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果</p>
<ul>
<li>有<strong>一个结果</strong>需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject </li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者） </li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式，因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<p><img src="https://s1.ax1x.com/2022/08/03/vZ3hi6.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Object response;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件不满足则等待</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <br>            &#125;<br>            <span class="hljs-keyword">return</span> response; <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 条件满足，通知等待线程</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            lock.notifyAll();<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<span class="hljs-comment">//增加了等待时间</span><br>    <span class="hljs-comment">// 标识 Guarded Object</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-comment">// timeout 表示要等待多久 2000</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 开始时间 15:00:00</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-comment">// 经历的时间</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">passedTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//   未等待时间   需等待时间 已等待时间</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> timeout - passedTime;<br>                <span class="hljs-comment">// 经历的时间超过了最大等待时间时，退出循环</span><br>                <span class="hljs-keyword">if</span> (timeout - passedTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.wait(waitTime); <span class="hljs-comment">// 虚假唤醒 15:00:01</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">// 求得经历时间</span><br>                passedTime = System.currentTimeMillis() - begin; <span class="hljs-comment">// 15:00:02 1s</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 给结果成员变量赋值</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mailboxes</span> &#123;<br>    <span class="hljs-comment">//中间解耦类，聚合了上方的中间类,表示信箱</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 产生唯一 id</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.remove(id);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject <span class="hljs-title function_">createGuardedObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>(generateId());<br>        boxes.put(go.getId(), go);<br>        <span class="hljs-keyword">return</span> go;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.keySet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">//模拟快递员</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String mail;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Postman</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String mail)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.mail = mail;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.getGuardedObject(id);<br>        log.debug(<span class="hljs-string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);<br>        guardedObject.complete(mail);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-comment">//模拟收件人</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 收信</span><br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.createGuardedObject();<br>        log.debug(<span class="hljs-string">&quot;开始收信 id:&#123;&#125;&quot;</span>, guardedObject.getId());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">mail</span> <span class="hljs-operator">=</span> guardedObject.get(<span class="hljs-number">5000</span>);<br>        log.debug(<span class="hljs-string">&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//测试</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>().start();<br>    &#125;<br>    Sleeper.sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Postman</span>(id, <span class="hljs-string">&quot;内容&quot;</span> + id).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">运行结果<br><span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">05.689</span> c.People [Thread-<span class="hljs-number">1</span>] - 开始收信 id:<span class="hljs-number">3</span><br><span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">05.689</span> c.People [Thread-<span class="hljs-number">2</span>] - 开始收信 id:<span class="hljs-number">1</span><br><span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">05.689</span> c.People [Thread-<span class="hljs-number">0</span>] - 开始收信 id:<span class="hljs-number">2</span><br><span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">06.688</span> c.Postman [Thread-<span class="hljs-number">4</span>] - 送信 id:<span class="hljs-number">2</span>, 内容:内容<span class="hljs-number">2</span><br><span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">06.688</span> c.Postman [Thread-<span class="hljs-number">5</span>] - 送信 id:<span class="hljs-number">1</span>, 内容:内容<span class="hljs-number">1</span><br><span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">06.688</span> c.People [Thread-<span class="hljs-number">0</span>] - 收到信 id:<span class="hljs-number">2</span>, 内容:内容<span class="hljs-number">2</span><br><span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">06.688</span> c.People [Thread-<span class="hljs-number">2</span>] - 收到信 id:<span class="hljs-number">1</span>, 内容:内容<span class="hljs-number">1</span><br><span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">06.688</span> c.Postman [Thread-<span class="hljs-number">3</span>] - 送信 id:<span class="hljs-number">3</span>, 内容:内容<span class="hljs-number">3</span><br><span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">06.689</span> c.People [Thread-<span class="hljs-number">1</span>] - 收到信 id:<span class="hljs-number">3</span>, 内容:内容<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>产生结果的线程和使用结果的线程一一对应</strong></li>
</ul>
<h4 id="生产者-x2F-消费者模式"><a href="#生产者-x2F-消费者模式" class="headerlink" title="生产者&#x2F;消费者模式"></a><strong>生产者&#x2F;消费者模式</strong></h4><p><strong>(异步)模式之生产者&#x2F;消费者</strong></p>
<ul>
<li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应 </li>
<li>消费队列可以用来平衡生产和消费的线程资源 </li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据 </li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据 </li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ul>
<p><img src="https://s1.ax1x.com/2022/08/04/veoleU.md.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;<br>    <span class="hljs-comment">//定义消息</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> Object message;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(<span class="hljs-type">int</span> id, Object message)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.message = message;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;<br>    <span class="hljs-comment">//定义消息队列</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; queue;<span class="hljs-comment">//共享变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//消费</span><br>        <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                log.debug(<span class="hljs-string">&quot;没货了, wait&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            queue.notifyAll();<span class="hljs-comment">//消费后通知生产者</span><br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Message message)</span> &#123;<br>        <span class="hljs-comment">//生产</span><br>        <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                log.debug(<span class="hljs-string">&quot;库存已达上限, wait&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            queue.addLast(message);<br>            queue.notifyAll();<span class="hljs-comment">//生产后通知消费者</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MessageQueue</span> <span class="hljs-variable">messageQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 4 个生产者线程, 下载任务</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;download...&quot;</span>);<br>            List&lt;String&gt; response = Downloader.download();<br>            log.debug(<span class="hljs-string">&quot;try put message(&#123;&#125;)&quot;</span>, id);<br>            messageQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(id, response));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i).start();<br>&#125;<br><br><span class="hljs-comment">// 1 个消费者线程, 处理结果</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> messageQueue.take();<br>        List&lt;String&gt; response = (List&lt;String&gt;) message.getMessage();<br>        log.debug(<span class="hljs-string">&quot;take message(&#123;&#125;): [&#123;&#125;] lines&quot;</span>, message.getId(), response.size());<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;消费者&quot;</span>).start();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">结果<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">38.070</span> [生产者<span class="hljs-number">3</span>] c.TestProducerConsumer - download...<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">38.070</span> [生产者<span class="hljs-number">0</span>] c.TestProducerConsumer - download...<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">38.070</span> [消费者] c.MessageQueue - 没货了, wait<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">38.070</span> [生产者<span class="hljs-number">1</span>] c.TestProducerConsumer - download...<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">38.070</span> [生产者<span class="hljs-number">2</span>] c.TestProducerConsumer - download...<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.236</span> [生产者<span class="hljs-number">1</span>] c.TestProducerConsumer - <span class="hljs-keyword">try</span> put <span class="hljs-title function_">message</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span><br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.237</span> [生产者<span class="hljs-number">2</span>] c.TestProducerConsumer - <span class="hljs-keyword">try</span> put <span class="hljs-title function_">message</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span><br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.236</span> [生产者<span class="hljs-number">0</span>] c.TestProducerConsumer - <span class="hljs-keyword">try</span> put <span class="hljs-title function_">message</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span><br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.237</span> [生产者<span class="hljs-number">3</span>] c.TestProducerConsumer - <span class="hljs-keyword">try</span> put <span class="hljs-title function_">message</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span><br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.239</span> [生产者<span class="hljs-number">2</span>] c.MessageQueue - 库存已达上限, wait<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.240</span> [生产者<span class="hljs-number">1</span>] c.MessageQueue - 库存已达上限, wait<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.240</span> [消费者] c.TestProducerConsumer - take <span class="hljs-title function_">message</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>: [<span class="hljs-number">3</span>] lines<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.240</span> [生产者<span class="hljs-number">2</span>] c.MessageQueue - 库存已达上限, wait<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.240</span> [消费者] c.TestProducerConsumer - take <span class="hljs-title function_">message</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>: [<span class="hljs-number">3</span>] lines<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.240</span> [消费者] c.TestProducerConsumer - take <span class="hljs-title function_">message</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>: [<span class="hljs-number">3</span>] lines<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.240</span> [消费者] c.TestProducerConsumer - take <span class="hljs-title function_">message</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>: [<span class="hljs-number">3</span>] lines<br><span class="hljs-number">10</span>:<span class="hljs-number">48</span>:<span class="hljs-number">41.240</span> [消费者] c.MessageQueue - 没货了, wait<br></code></pre></td></tr></table></figure>

<h4 id="park与unpark"><a href="#park与unpark" class="headerlink" title="park与unpark"></a>park与unpark</h4><ul>
<li><p>暂停当前线程</p>
<ul>
<li>LockSupport.park();</li>
</ul>
</li>
<li><p>恢复某个线程的运行</p>
<ul>
<li>LockSupport.unpark(暂停线程对象)</li>
</ul>
</li>
</ul>
<p>与 Object 的 wait &amp; notify 相比 </p>
<ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>
<li><strong>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】</strong> </li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>
</ul>
<p><strong>死锁：</strong>在两个或多个并发进程中，如果每个进程持有某种资源而又都等待着别的进程释放它或它们现在保持着的资源，否则就不能向前推进，此时每个进程都占用了一定的资源但又都不能向前推进，称这一组进程产生了死锁</p>
<p><strong>活锁：</strong>两个线程互相改变对方的结束条件，最后谁也无法结束</p>
<p><strong>饥饿：</strong>当线程需要某些资源(通常是CPU资源) , 但却始终获得不到.造成饥饿的情况</p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>相对于 synchronized 它具备如下特点 </p>
<ul>
<li>可中断 </li>
<li>可以设置超时时间 </li>
<li>可以设置为公平锁 (避免饥饿)</li>
<li>支持多个条件变量</li>
</ul>
<p>与 synchronized 一样，都支持可重入 </p>
<p><strong>基本语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h5><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 </p>
<p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p>
<h5 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//没有竞争就会获取锁</span><br>        <span class="hljs-comment">//有竞争就进入阻塞队列等待,但可以被打断</span><br>        lock.lockInterruptibly();<br>        <span class="hljs-comment">//lock.lock(); //不可打断</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>        log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><br><span class="hljs-keyword">try</span> &#123;<br>    sleep(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;执行打断&quot;</span>);<br>    t1.interrupt();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;启动...&quot;</span>);<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>            log.debug(<span class="hljs-string">&quot;获取等待 1s 后失败，返回&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>lock.lock();<br>log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>t1.start();<br><br><span class="hljs-keyword">try</span> &#123;<br>    sleep(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待<br>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比 </p>
<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息 </li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitCigaretteQueue</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitbreakfastQueue</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigrette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasBreakfast</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">while</span> (!hasCigrette) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    waitCigaretteQueue.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;等到了它的烟&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;).start();<br>    <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">while</span> (!hasBreakfast) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    waitbreakfastQueue.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;等到了它的早餐&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;).start();<br>    <br>    sleep(<span class="hljs-number">1</span>);<br>    sendBreakfast();<br>    sleep(<span class="hljs-number">1</span>);<br>    sendCigarette();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendCigarette</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;送烟来了&quot;</span>);<br>        hasCigrette = <span class="hljs-literal">true</span>;<br>        waitCigaretteQueue.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendBreakfast</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;送早餐来了&quot;</span>);<br>        hasBreakfast = <span class="hljs-literal">true</span>;<br>        waitbreakfastQueue.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h3><ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响 </li>
<li>可见性 - 保证指令不会受 cpu 缓存的影响 </li>
<li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>先来看个问题：<strong>退不出的死循环？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span>(run)&#123;<br>            <span class="hljs-comment">// ....</span><br>        &#125;<br>    &#125;);<br>    t.start();<br>    <br>    sleep(<span class="hljs-number">1</span>);<br>    run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>为啥呢？？？</strong></li>
</ul>
<ol>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li>
</ol>
<p><img src="https://s1.ax1x.com/2022/08/05/vnJ7bF.md.png"></p>
<ol start="2">
<li>因为 t 线程要频繁从主内存中读取 run 的值，<strong>JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</strong></li>
</ol>
<p><img src="https://s1.ax1x.com/2022/08/05/vnJxv6.md.png"></p>
<ol start="3">
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li>
</ol>
<p><img src="https://s1.ax1x.com/2022/08/05/vnYPVe.md.png"></p>
<p><strong>解决办法</strong>：</p>
<p>volatile（易变关键字） </p>
<p>它可以用来修饰成员变量和静态成员变量，<strong>他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</strong></p>
<p><strong>可见性：</strong>它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，但不能保证原子性，仅用在一个写线程，多个读线程的情况(<strong>也就是保证读取的是最新的，但不能阻止指令重排</strong>)</p>
<blockquote>
<p>注意<br>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是<br>synchronized 是属于重量级操作，性能相对更低 </p>
<p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？<br>因为其内部包含了synchronized 的使用</p>
</blockquote>
<h4 id="犹豫模式"><a href="#犹豫模式" class="headerlink" title="犹豫模式"></a>犹豫模式</h4><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorService</span> &#123;<br>    <br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> starting;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 真正启动监控线程...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> j;<br><br><span class="hljs-comment">// 在某个线程内执行如下赋值操作</span><br>i = ...; <br>j = ...;<br><br><br><span class="hljs-comment">//可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</span><br>i = ...; <br>j = ...;<br>------------------------------------------<br>j = ...;<br>i = ...;<br></code></pre></td></tr></table></figure>

<p><strong>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。</strong></p>
<h4 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h4><ul>
<li><p><strong>如何保证可见性？</strong></p>
<ul>
<li>volatile 的底层实现原理是内存屏障，<strong>Memory Barrier（Memory Fence）</strong> <ul>
<li>对 volatile 变量的写指令后会加入写屏障 ，写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li>
<li>对 volatile 变量的读指令前会加入读屏障，而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>如何保证有序性？</strong></p>
<ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
</li>
</ul>
<blockquote>
<p>还是那句话，不能解决指令交错</p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去 </li>
<li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li>
</ul>
</blockquote>
<hr>
<h3 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h3><h4 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountSafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> AtomicInteger balance; <span class="hljs-comment">//原子整数</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountSafe</span><span class="hljs-params">(Integer balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(balance);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<span class="hljs-comment">//CAS</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？<ul>
<li>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2022/08/07/vK8JMV.md.png" alt="vK8JMV.md.png"></p>
<blockquote>
<p>CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</p>
<p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被</p>
<p>线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p>
</blockquote>
<p><strong>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</strong> </p>
<ul>
<li>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</li>
</ul>
<blockquote>
<p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</p>
</blockquote>
<p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。 </p>
<ul>
<li>CAS <strong>是基于乐观锁的思想</strong>：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 </li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁,你们才有机会。 </li>
<li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思 <ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 </li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h4 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span><br>System.out.println(i.getAndIncrement());<br><br><span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>System.out.println(i.incrementAndGet());<br><br><span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>System.out.println(i.decrementAndGet());<br><br><span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>System.out.println(i.getAndDecrement());<br><br><span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span><br>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br><br><span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span><br>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br><br><span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br><span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span><br><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span><br>System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br><br><span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br></code></pre></td></tr></table></figure>

<h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecimalAccountSafeCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br>    AtomicReference&lt;BigDecimal&gt; ref;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecimalAccountSafeCas</span><span class="hljs-params">(BigDecimal balance)</span> &#123;<br>        ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(balance);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ref.get();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.get();<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.subtract(amount);<br>            <span class="hljs-keyword">if</span> (ref.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况</strong></p>
<p>如果主线程希望： 只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号 </p>
<blockquote>
<p>可使用AtomicStampedReference 实现</p>
<p>AtomicStampedReference<String> ref &#x3D; new AtomicStampedReference&lt;&gt;(“A”, 0);</p>
<p>不关心引用变量更改了几次，只是单纯的关心是否更改过，可使用 AtomicMarkableReference</p>
<p>AtomicMarkableReference<GarbageBag> ref &#x3D; new AtomicMarkableReference&lt;&gt;(bag, true);</p>
</blockquote>
<h4 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment">    参数2，获取数组长度的方法</span><br><span class="hljs-comment">    参数3，自增方法，回传 array, index</span><br><span class="hljs-comment">    参数4，打印数组的方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// supplier 提供者 无中生有 ()-&gt;结果</span><br><span class="hljs-comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span><br><span class="hljs-comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">    Supplier&lt;T&gt; arraySupplier,</span><br><span class="hljs-params">    Function&lt;T, Integer&gt; lengthFun,</span><br><span class="hljs-params">    BiConsumer&lt;T, Integer&gt; putConsumer,</span><br><span class="hljs-params">    Consumer&lt;T&gt; printConsumer )</span> &#123;<br>    <br>    List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> arraySupplier.get();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lengthFun.apply(array);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span><br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                putConsumer.accept(array, j%length);<br>            &#125;<br>        &#125;));<br>    &#125;<br>    ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>    <br>    ts.forEach(t -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;); <span class="hljs-comment">// 等所有线程结束</span><br>    printConsumer.accept(array);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>原子数组实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br>    ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br>    (array) -&gt; array.length(),<br>    (array, index) -&gt; array.getAndIncrement(index),<br>    array -&gt; System.out.println(array)<br>);<br></code></pre></td></tr></table></figure>

<h4 id="原子字段更新器"><a href="#原子字段更新器" class="headerlink" title="原子字段更新器"></a>原子字段更新器</h4><ul>
<li>利用字段更新器，可以针对对象的某个<strong>域（Field）进行原子操作</strong>，只能配合 volatile 修饰的字段使用，<br>否则会出现异常 Exception in thread “main” java.lang.IllegalArgumentException: Must be volatile type</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> field;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">fieldUpdater</span> <span class="hljs-operator">=</span>AtomicIntegerFieldUpdater.newUpdater(Test5.class, <span class="hljs-string">&quot;field&quot;</span>);<br>        <br>        <span class="hljs-type">Test5</span> <span class="hljs-variable">test5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test5</span>();<br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 修改成功 field = 10</span><br>        System.out.println(test5.field);<br>        <span class="hljs-comment">// 修改成功 field = 20</span><br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(test5.field);<br>        <span class="hljs-comment">// 修改失败 field = 20</span><br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>);<br>        System.out.println(test5.field);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h3><p><strong>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改</strong></p>
<h4 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <br>    <span class="hljs-comment">// ...</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>发现该类、类中所有属性都是 final 的 </p>
<ul>
<li>属性用 final 修饰保证了该属性是只读的，不能修改 </li>
<li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li>
</ul>
<blockquote>
<p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。<br>这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】</p>
</blockquote>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况</p>
<h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，<strong>这种没有任何成员变量的类是线程安全的</strong> </p>
<blockquote>
<p>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</p>
</blockquote>
<hr>
<h3 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h3><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ul>
<li><strong>一个容纳多个线程的容器，容器中的线程可以重复使用，省去了频繁创建和销毁线程对象的操作</strong></li>
</ul>
<p><strong>线程池作用：</strong></p>
<ol>
<li>降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li>
<li>提高响应速度，当任务到达时，如果有线程可以直接用，不会出现系统僵死</li>
<li>提高线程的可管理性，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ol>
<ul>
<li>线程池的核心思想：<strong>线程复用</strong>，同一个线程可以被重复使用，来处理多个任务</li>
<li>池化技术 (Pool) ：一种编程技巧，核心思想是资源复用，在请求量大时能优化应用性能，降低系统频繁建连的资源开销</li>
</ul>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img src="https://s1.ax1x.com/2022/08/09/v1S5AU.png"></p>
<ol>
<li>创建线程池，这时没有创建线程（<strong>懒惰</strong>），等待提交过来的任务请求，调用 execute 方法才会创建线程</li>
<li>当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：<ul>
<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列</li>
<li>如果这时队列满了且正在运行的线程数量还小于 <code>maximumPoolSize</code>，那么会创建非核心线程<strong>立刻运行这个任务</strong>，对于阻塞队列中的任务不公平。这是因为创建每个 Worker（线程）对象会绑定一个初始任务，启动 Worker 时会优先执行</li>
<li>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和<strong>拒绝策略</strong>来执行</li>
</ul>
</li>
<li>当一个线程完成任务时，会从队列中取下一个任务来执行</li>
<li>当一个线程空闲超过一定的时间（keepAliveTime）时，线程池会判断：如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉，所以线程池的所有任务完成后最终会收缩到 corePoolSize 大小</li>
</ol>
<h5 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h5><p><strong>ThreadPoolExecutor</strong>：</p>
<p>构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure>

<p>参数介绍：</p>
<ul>
<li><p>corePoolSize：核心线程数，定义了最小可以同时运行的线程数量</p>
</li>
<li><p>maximumPoolSize：最大线程数，当队列中存放的任务达到队列容量时，当前可以同时运行的数量变为最大线程数，创建线程并立即执行最新的任务，<strong>与核心线程数之间的差值又叫救急线程数</strong></p>
</li>
<li><p>keepAliveTime：救急线程最大存活时间，当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等到 <code>keepAliveTime</code> 时间超过销毁</p>
</li>
<li><p>unit：<code>keepAliveTime</code> 参数的时间单位</p>
</li>
<li><p>workQueue：阻塞队列，存放被提交但尚未被执行的任务</p>
</li>
<li><p>threadFactory：线程工厂，创建新线程时用到，可以为线程创建时起名字</p>
</li>
<li><p>handler：拒绝策略，线程到达最大线程数仍有新任务时会执行拒绝策略</p>
<p>RejectedExecutionHandler 下有 4 个实现类：</p>
<ul>
<li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>默认策略</strong></li>
<li>CallerRunsPolicy：让调用者运行的调节机制，将某些任务回退到调用者，从而降低新任务的流量</li>
<li>DiscardPolicy：直接丢弃任务，不予任何处理也不抛出异常</li>
<li>DiscardOldestPolicy：放弃队列中最早的任务，把当前任务加入队列中尝试再次提交当前任务</li>
</ul>
<p>补充：其他框架拒绝策略</p>
<ul>
<li>Dubbo：在抛出 RejectedExecutionException 异常前记录日志，并 dump 线程栈信息，方便定位问题</li>
<li>Netty：创建一个新线程来执行任务</li>
<li>ActiveMQ：带超时等待（60s）尝试放入队列</li>
<li>PinPoint：它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul>
</li>
</ul>
<h5 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h5><p>Executors 提供了四种线程池的创建：</p>
<p><code>newFixedThreadPool</code></p>
<p><code>newCachedThreadPool</code></p>
<p><code>newSingleThreadExecutor</code></p>
<p><code>newScheduledThreadPool</code></p>
<hr>
<ul>
<li><p><code>newFixedThreadPool</code></p>
<ul>
<li>&#96;&#96;&#96;java<br>public static ExecutorService newFixedThreadPool(int nThreads) {<br>return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,<br>                              new LinkedBlockingQueue<Runnable>());<br>}<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><br>    - 核心线程数 == 最大线程数（**没有救急线程被创建**），因此也无需超时时间<br>    - LinkedBlockingQueue 是一个单向链表实现的阻塞队列，默认大小为 `Integer.MAX_VALUE`，也就是**无界队列**，可以放任意数量的任务，在任务比较多的时候会导致 OOM（内存溢出）<br>    - 适用于任务量已知，相对耗时的长期任务<br><br>- `<span class="hljs-keyword">new</span><span class="hljs-type">CachedThreadPool</span>`<br><br>  - ```java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">CachedThreadPool</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE, <span class="hljs-number">60</span>L, TimeUnit.SECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-type">SynchronousQueue</span>&lt;Runnable&gt;());<br>    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>核心线程数是 0， 最大线程数是 29 个 1，<strong>全部都是救急线程</strong>（60s 后可以回收），可能会创建大量线程，从而导致 <strong>OOM</strong></li>
<li>SynchronousQueue 作为阻塞队列，<strong>没有容量</strong>，对于每一个 take 的线程会阻塞直到有一个 put 的线程放入元素为止（类似一手交钱、一手交货）</li>
<li>适合任务数比较密集，但每个任务执行时间较短的情况</li>
</ul>
</li>
</ul>
</li>
<li><p><code>newSingleThreadExecutor</code></p>
<ul>
<li>&#96;&#96;&#96;java<br>public static ExecutorService newSingleThreadExecutor() {<br>return new FinalizableDelegatedExecutorService<br>    (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,<br>                            new LinkedBlockingQueue<Runnable>()));<br>}<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br>    - 保证所有任务按照<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>指定顺序执行<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>，线程数固定为 1，任务数多于 1 时会放入无界队列排队，任务执行完毕，这唯一的线程也不会被释放<br><br>  对比：<br><br>  - <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，线程池会新建一个线程，保证池的正常工作<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br><br>  - Executors.newSingleThreadExecutor() 线程个数始终为 1，不能修改。FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法<br><br>    原因：父类不能直接调用子类中的方法，需要反射或者创建对象的方式，可以调用子类静态方法<br><br>  - Executors.newFixedThreadPool(1) 初始时为 1，可以修改。对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改<br><br><span class="hljs-comment">##### 提交方法</span><br><br>ExecutorService 类 API：<br><br>|<span class="hljs-string"> 方法                                                         </span>|<span class="hljs-string"> 说明                                                         </span>|<br>|<span class="hljs-string"> ------------------------------------------------------------ </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>|<br>|<span class="hljs-string"> void execute(Runnable command)                               </span>|<span class="hljs-string"> 执行任务（Executor 类 API）                                  </span>|<br>|<span class="hljs-string"> Future&lt;?&gt; submit(Runnable task)                              </span>|<span class="hljs-string"> 提交任务 task()                                              </span>|<br>|<span class="hljs-string"> Future submit(Callable task)                                 </span>|<span class="hljs-string"> 提交任务 task，用返回值 Future 获得任务执行结果              </span>|<br>|<span class="hljs-string"> List&lt;Future&gt; invokeAll(Collection&lt;? extends Callable&gt; tasks) </span>|<span class="hljs-string"> 提交 tasks 中所有任务                                        </span>|<br>|<span class="hljs-string"> List&lt;Future&gt; invokeAll(Collection&lt;? extends Callable&gt; tasks, long timeout, TimeUnit unit) </span>|<span class="hljs-string"> 提交 tasks 中所有任务，超时时间针对所有task，超时会取消没有执行完的任务，并抛出超时异常 </span>|<br>|<span class="hljs-string"> T invokeAny(Collection&lt;? extends Callable&gt; tasks)            </span>|<span class="hljs-string"> 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消 </span>|<br><br>execute 和 submit 都属于线程池的方法，对比：<br><br>- execute 只能执行 Runnable 类型的任务，没有返回值； submit 既能提交 Runnable 类型任务也能提交 Callable 类型任务，底层是<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>封装成 FutureTask，然后调用 execute 执行<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br>- execute 会直接抛出任务执行时的异常，submit 会吞掉异常，可通过 Future 的 get 方法将任务执行时的异常重新抛出<br><br><span class="hljs-comment">##### 关闭方法</span><br><br>ExecutorService 类 API：<br><br>|<span class="hljs-string"> 方法                                                  </span>|<span class="hljs-string"> 说明                                                         </span>|<br>|<span class="hljs-string"> ----------------------------------------------------- </span>|<span class="hljs-string"> ------------------------------------------------------------ </span>|<br>|<span class="hljs-string"> void shutdown()                                       </span>|<span class="hljs-string"> 线程池状态变为 SHUTDOWN，**等待任务执行完后关闭线程池**，不会接收新任务，但已提交任务会执行完，而且也可以添加线程（不绑定ren&#x27;wu） </span>|<br>|<span class="hljs-string"> List shutdownNow()                                    </span>|<span class="hljs-string"> 线程池状态变为 STOP，用 interrupt **中断正在执行的任务**，直接关闭线程池，不会接收新任务，会将队列中的任务返回 </span>|<br>|<span class="hljs-string"> boolean isShutdown()                                  </span>|<span class="hljs-string"> 不在 RUNNING 状态的线程池，此执行者已被关闭，方法返回 true   </span>|<br>|<span class="hljs-string"> boolean isTerminated()                                </span>|<span class="hljs-string"> 线程池状态是否是 TERMINATED，如果所有任务在关闭后完成，返回 true </span>|<br>|<span class="hljs-string"> boolean awaitTermination(long timeout, TimeUnit unit) </span>|<span class="hljs-string"> 调用 shutdown 后，由于调用线程不会等待所有任务运行结束，如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待 </span>|<br><br><span class="hljs-comment">##### 工作线程模式</span><br><br><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>。也可以将其归类为分工模式，它的典型实现 <br>就是线程池，也体现了经典设计模式中的享元模式。<br><br>注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率 <br><br><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>案例：<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span><br><br>```java<br>public class TestStarvation &#123;<br>    <br>    static final List<span class="hljs-variable">&lt;String&gt;</span> MENU = Arrays.asList(<span class="hljs-string">&quot;地三鲜&quot;</span>, <span class="hljs-string">&quot;宫保鸡丁&quot;</span>, <span class="hljs-string">&quot;辣子鸡丁&quot;</span>, <span class="hljs-string">&quot;烤鸡翅&quot;</span>);<br>    static Random RANDOM = new Random();<br>    <br>    static String cooking() &#123;<br>        return MENU.get(RANDOM.nextInt(MENU.size()));<br>    &#125;<br>    <br>    public static void main(String[] args) &#123;<br>        ExecutorService executorService = Executors.newFixedThreadPool(2);<br>        <br>        executorService.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;处理点餐...&quot;</span>);<br>            Future<span class="hljs-variable">&lt;String&gt;</span> f = executorService.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜&quot;</span>);<br>                return cooking();<br>            &#125;);<br>            try &#123;<br>                log.debug(<span class="hljs-string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());<br>            &#125; catch (InterruptedException |<span class="hljs-string"> ExecutionException e) &#123;</span><br><span class="hljs-string">                e.printStackTrace();</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">        /*</span><br><span class="hljs-string">        executorService.execute(() -&gt; &#123;</span><br><span class="hljs-string">            log.debug(&quot;处理点餐...&quot;);</span><br><span class="hljs-string">            Future&lt;String&gt; f = executorService.submit(() -&gt; &#123;</span><br><span class="hljs-string">                log.debug(&quot;做菜&quot;);</span><br><span class="hljs-string">                return cooking();</span><br><span class="hljs-string">            &#125;);</span><br><span class="hljs-string">            try &#123;</span><br><span class="hljs-string">                log.debug(&quot;上菜: &#123;&#125;&quot;, f.get());</span><br><span class="hljs-string">            &#125; catch (InterruptedException </span>|<span class="hljs-string"> ExecutionException e) &#123;</span><br><span class="hljs-string">                e.printStackTrace();</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &#125;);</span><br><span class="hljs-string">        */</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>固定大小线程池会有饥饿现象 </p>
<ul>
<li>两个工人是同一个线程池中的两个线程 </li>
<li>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作 <ul>
<li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待 </li>
<li>后厨做菜：没啥说的，做就是了</li>
</ul>
</li>
<li>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好 </li>
<li>但现在同时来了两个客人，这个时候<strong>工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</strong></li>
</ul>
<p><strong>解决办法：不同的任务类型，采用不同的线程池</strong></p>
<blockquote>
<p><strong>创建多少线程池合适</strong> ?</p>
<ul>
<li><p>CPU 密集型运算 </p>
</li>
<li><p>通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因<br>导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p>
</li>
<li><p>I&#x2F;O 密集型运算 </p>
</li>
<li><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程<br>RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 </p>
</li>
<li><p>线程数 &#x3D; 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) &#x2F; CPU 计算时间</p>
</li>
</ul>
</blockquote>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>execute 会直接抛出任务执行时的异常，submit 会吞掉异常，有两种处理方法</p>
<p>方法 1：主动捉异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>pool.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;task1&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>方法 2：使用 Future 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>Future&lt;?&gt; future = pool.submit(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;task1&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;);<br>System.out.println(future.get());<br></code></pre></td></tr></table></figure>

<h5 id="Fork-x2F-Join"><a href="#Fork-x2F-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h5><ul>
<li>Fork&#x2F;Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算 </li>
<li>Fork&#x2F;Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率 </li>
<li>Fork&#x2F;Join 默认会创建与 cpu 核心数大小相同的线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTask1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-type">int</span> n;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 将任务进行拆分(fork)</span><br>        <span class="hljs-type">AddTask1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask1</span>(n - <span class="hljs-number">1</span>);<br>        t1.fork();<br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);<br>        <br>        <span class="hljs-comment">// 合并(join)结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> n + t1.join();<br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h4><p><strong><code>AQS(AbstractQueuedSynchronizer) </code>原理</strong></p>
<ul>
<li>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架 <ul>
<li>队列同步器是用来<strong>构建锁的基础框架</strong>，如 ReentrantLock 和 ReentrantReadWriteLock 中的同步器 Sync 就是对队列同步器的具体实现。同步器 Sync <strong>帮助锁隐藏了实现细节以及简化了锁的实现</strong>，开发者只需要关心锁的具体使用方法就行。</li>
</ul>
</li>
<li>AQS 用状态属性来表示资源的状态（分<strong>独占模式和共享模式</strong>），子类需要定义如何维护这个状态，控制如何获取锁和释放锁</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList </li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p><strong>ReentrantReadWriteLock</strong></p>
<ul>
<li>当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select … from … lock in share mode </li>
<li><strong>读-读 可并发</strong></li>
<li><strong>读-写 &#x2F; 写-写 互斥</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainer</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> Object data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rw.readLock();<br>    <span class="hljs-keyword">private</span> ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rw.writeLock();<br>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获取读锁...&quot;</span>);<br>        r.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;读取&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放读锁...&quot;</span>);<br>            r.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;获取写锁...&quot;</span>);<br>        w.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;写入&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放写锁...&quot;</span>);<br>            w.unlock();<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><ul>
<li><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在<strong>使用读锁、写锁时都必须配合【戳】使用加解读锁</strong> </p>
</li>
<li><p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次戳校验</p>
<ul>
<li>如果校验通过，表示这期间确实没有写操作，数据可以安全使用。</li>
<li>如果校验没通过，需要重新获取读锁，保证数据安全。</li>
</ul>
</li>
</ul>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量，用来限制能同时访问共享资源的线程上限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 1. 创建 semaphore 对象</span><br>    <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// 2. 10个线程同时运行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 3. 获取许可</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                semaphore.acquire();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>                sleep(<span class="hljs-number">1</span>);<br>                log.debug(<span class="hljs-string">&quot;end...&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 4. 释放许可</span><br>                semaphore.release();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h4 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h4><p>用来进行线程同步协作，等待所有线程完成倒计时。 </p>
<p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br>    <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br>    <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br>    <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1.5</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br>    <br>    log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>    latch.await();<br>    log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><ul>
<li>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』</li>
<li>每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，<strong>当等待的线程数满足『计数个数』时，继续执行.</strong></li>
<li>可重复使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 个数为2时才会继续执行</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;线程1开始..&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-keyword">try</span> &#123;<br>        cb.await(); <span class="hljs-comment">// 当个数不足时，等待</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;线程1继续向下运行...&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;线程2开始..&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-keyword">try</span> &#123; <br>        Thread.sleep(<span class="hljs-number">2000</span>); <br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        cb.await(); <span class="hljs-comment">// 2 秒后，线程个数够2，继续运行</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;线程2继续向下运行...&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>&#125;).start();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意 CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 </p>
<p>CyclicBarrier 可以被比喻为『人满发车』</p>
</blockquote>
<h4 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lw-maple.github.io">Lost丶逝水如风</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lw-maple.github.io/2022/08/10/2022-8-10-%E3%80%90JUC%E3%80%91/">https://lw-maple.github.io/2022/08/10/2022-8-10-【JUC】/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lw-maple.github.io" target="_blank">漫漫长夜</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"><div class="social-share" data-image="/img/coverImg/10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/13/2022-8-13-%E3%80%90%E5%89%91%E6%8C%87Offer(%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84)%E3%80%91/"><img class="prev-cover" src="/img/coverImg/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">剑指Offer【树的子结构】</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/10/2022-8-10-%E3%80%90%E5%89%91%E6%8C%87Offer(%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2)%E3%80%91/"><img class="next-cover" src="/img/coverImg/22.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">剑指Offer【把数字翻译成字符串】</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">Java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">实现多线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB%EF%BC%8C%E9%87%8D%E5%86%99%E8%AF%A5%E7%B1%BB%E7%9A%84run-%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.继承Thread类，重写该类的run()方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%B9%B6%E9%87%8D%E5%86%99%E8%AF%A5%E6%8E%A5%E5%8F%A3%E7%9A%84run-%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.实现Runnable接口，并重写该接口的run()方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0-Callable-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E3%80%82"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.实现 Callable 接口：接口创建线程。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%AF%E5%8A%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">4.通过线程池启动多线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.</span> <span class="toc-text">五种状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized"><span class="toc-number">2.5.</span> <span class="toc-text">synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">共享模型之管程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-number">3.1.</span> <span class="toc-text">变量的线程安全分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">常见线程安全类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E4%B9%8B-Monitor-%E9%94%81"><span class="toc-number">3.3.</span> <span class="toc-text">原理之 Monitor(锁)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%88%E8%86%A8%E8%83%80%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">重量级锁（膨胀）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.3.</span> <span class="toc-text">自旋优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">3.3.4.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">3.3.5.</span> <span class="toc-text">锁消除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-x2F-notify"><span class="toc-number">3.4.</span> <span class="toc-text">wait&#x2F;notify</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C"><span class="toc-number">3.5.</span> <span class="toc-text">保护性暂停</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">3.5.1.</span> <span class="toc-text">拓展</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-x2F-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">生产者&#x2F;消费者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#park%E4%B8%8Eunpark"><span class="toc-number">3.7.</span> <span class="toc-text">park与unpark</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">3.8.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">3.8.1.</span> <span class="toc-text">可重入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD"><span class="toc-number">3.8.2.</span> <span class="toc-text">可打断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E8%B6%85%E6%97%B6"><span class="toc-number">3.8.3.</span> <span class="toc-text">锁超时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.8.4.</span> <span class="toc-text">条件变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">共享模型之内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B9%E8%B1%AB%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">犹豫模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">volatile原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">共享模型之无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E4%B8%8Evolatile"><span class="toc-number">5.1.</span> <span class="toc-text">CAS与volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">原子整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">原子引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">5.4.</span> <span class="toc-text">原子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">原子字段更新器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">6.</span> <span class="toc-text">共享模型之不可变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.1.</span> <span class="toc-text">不可变设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final"><span class="toc-number">6.2.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">6.3.</span> <span class="toc-text">无状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">7.</span> <span class="toc-text">并发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.1.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">7.1.2.</span> <span class="toc-text">创建方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">7.1.3.</span> <span class="toc-text">实现类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">7.1.4.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Fork-x2F-Join"><span class="toc-number">7.1.5.</span> <span class="toc-text">Fork&#x2F;Join</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JUC"><span class="toc-number">7.2.</span> <span class="toc-text">JUC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">7.3.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#StampedLock"><span class="toc-number">7.3.1.</span> <span class="toc-text">StampedLock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore"><span class="toc-number">7.4.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CountdownLatch"><span class="toc-number">7.5.</span> <span class="toc-text">CountdownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">7.6.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">7.7.</span> <span class="toc-text">线程安全集合类</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Lost丶逝水如风</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>